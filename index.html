<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gamevibe Arena</title>
    <link rel="stylesheet" href="css/styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>
    <!-- Navigation Header -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <i class="fas fa-gamepad"></i>
                <span>Gamevibe Arena</span>
            </div>
            <div class="nav-menu">
                <a href="#dashboard" class="nav-link active" data-page="dashboard">
                    <i class="fas fa-tachometer-alt"></i> Dashboard
                </a>
                </a>
                <a href="#game-ideas" class="nav-link" data-page="game-ideas">
                    <i class="fas fa-palette"></i> Game Ideas
                </a>
                <a href="#object-finder" class="nav-link" data-page="object-finder">
                    <i class="fas fa-search"></i> Object Finder
                </a>
                </a>
                <a href="#leaderboard" class="nav-link" data-page="leaderboard">
                    <i class="fas fa-trophy"></i> Leaderboard
                </a>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Dashboard Page -->
        <div id="dashboard" class="page active">
            <div class="page-header">
                <h1><i class="fas fa-tachometer-alt"></i> Dashboard</h1>
                <p>Welcome to Gamevibe Arena</p>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-icon game-ideas">
                        <i class="fas fa-palette"></i>
                    </div>
                    <div class="stat-content">
                        <h3 id="statsGameIdeas">0</h3>
                        <p>Game Ideas Created</p>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon object-searches">
                        <i class="fas fa-search"></i>
                    </div>
                    <div class="stat-content">
                        <h3 id="statsObjectSearches">0</h3>
                        <p>Object Searches</p>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon leaderboard">
                        <i class="fas fa-trophy"></i>
                    </div>
                    <div class="stat-content">
                        <h3 id="statsMoodboards">0</h3>
                        <p>Moodboards on Leaderboard</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Games Page -->
        <div id="games" class="page">
            <div class="page-header">
                <h1><i class="fas fa-gamepad"></i> Games Library</h1>
                <div class="page-actions">
                    <button class="btn btn-success" onclick="showGameForm()">
                        <i class="fas fa-plus"></i> Add Game
                    </button>
                    <button class="btn btn-info" onclick="showGameBrowser()">
                        <i class="fas fa-search"></i> Browse CheapShark
                    </button>
                </div>
            </div>

            <!-- CheapShark Game Browser -->
            <div id="gameBrowser" class="form-container" style="display: none;">
                <div class="form-header">
                    <h3>Browse Games - CheapShark API</h3>
                    <button class="btn-close" onclick="hideGameBrowser()">×</button>
                </div>
                <div class="browser-content">
                    <div id="apiSearchResults" class="api-results">
                        <p class="text-center">Loading popular games from CheapShark API...</p>
                    </div>
                </div>
            </div>
            
            <!-- Game Form -->
            <div id="gameForm" class="form-container" style="display: none;">
                <h3 id="gameFormTitle">Add New Game</h3>
                <form id="gameFormElement" onsubmit="submitGameForm(event); return false;">
                    <input type="hidden" id="gameId" value="">
                    <div class="form-group">
                        <label for="gameTitle">Title *</label>
                        <input type="text" id="gameTitle" required>
                    </div>
                    <div class="form-group">
                        <label for="gameDeveloper">Developer *</label>
                        <input type="text" id="gameDeveloper" required>
                    </div>
                    <div class="form-group">
                        <label for="gameGenre">Genre (comma-separated)</label>
                        <input type="text" id="gameGenre" placeholder="Action, Adventure, RPG">
                    </div>
                    <div class="form-group">
                        <label for="gamePlatform">Platform (comma-separated)</label>
                        <input type="text" id="gamePlatform" placeholder="PC, Console, Mobile">
                    </div>
                    <div class="form-group">
                        <label for="gameDescription">Description</label>
                        <textarea id="gameDescription" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="gameStatus">Status</label>
                        <select id="gameStatus">
                            <option value="available">Available</option>
                            <option value="coming_soon">Coming Soon</option>
                            <option value="discontinued">Discontinued</option>
                        </select>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary" onclick="console.log('Save button clicked!')">Save Game</button>
                        <button type="button" class="btn btn-secondary" onclick="hideGameForm()">Cancel</button>
                    </div>
                </form>
            </div>
            
            <div class="content-filters">
                <input type="text" id="gamesSearch" placeholder="Search games..." class="search-input">
                <button onclick="filterGames()">Search</button>
            </div>

            <div class="games-grid" id="gamesGrid">
                <p>Loading games...</p>
            </div>
        </div>

        <!-- Game Ideas Page -->
        <div id="game-ideas" class="page">
            <div class="page-header">
                <h1><i class="fas fa-palette"></i> Game Ideas with AI</h1>
                <p>Create unique game concepts by mixing elements from real games in the CheapShark database!</p>
            </div>

            <!-- CheapShark Game Mixer -->
            <div class="generate-container">
                <div class="generation-form">
                    <h3><i class="fas fa-dice"></i> CheapShark Game Mixer</h3>
                    <p>Select games from CheapShark to mix their elements and create something completely new!</p>
                    
                    <!-- Game Selection Controls -->
                    <div class="mixer-controls">
                        <div class="form-row">
                            <div class="form-group">
                                <label for="gameCount">Number of games to mix</label>
                                <select id="gameCount" onchange="updateGameSelectors()">
                                    <option value="2">Mix 2 games</option>
                                    <option value="3" selected>Mix 3 games</option>
                                    <option value="4">Mix 4 games</option>
                                    <option value="5">Mix 5 games</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="mixingStyle">Mixing Style</label>
                                <select id="mixingStyle">
                                    <option value="balanced">Balanced Mix</option>
                                    <option value="genre_focus">Focus on Genre</option>
                                    <option value="mechanics_focus">Focus on Mechanics</option>
                                    <option value="story_focus">Focus on Story</option>
                                    <option value="art_focus">Focus on Art Style</option>
                                    <option value="random">Completely Random</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="form-actions">
                            <button class="btn btn-primary" onclick="loadCheapSharkGames()">
                                <i class="fas fa-download"></i> Load CheapShark Games
                            </button>
                            <button class="btn btn-secondary" onclick="randomlySelectGames()">
                                <i class="fas fa-random"></i> Random Selection
                            </button>
                        </div>
                    </div>

                    <!-- Game Selection Areas -->
                    <div id="gameSelectors" class="game-selectors">
                        <!-- Game selector dropdowns will be generated here -->
                    </div>

                    <!-- Selected Games Preview -->
                    <div id="selectedGamesPreview" class="selected-games-preview" style="display: none;">
                        <h4><i class="fas fa-eye"></i> Selected Games to Mix</h4>
                        <div id="gamePreviewCards" class="game-preview-cards">
                            <!-- Preview cards will appear here -->
                        </div>
                    </div>

                    <!-- Generation Controls -->
                    <div class="generation-controls" style="display: none;" id="generationControls">
                        <div class="form-group">
                            <label for="creativityLevel">AI Creativity Level</label>
                            <select id="creativityLevel">
                                <option value="conservative">Conservative (Stay close to originals)</option>
                                <option value="moderate" selected>Moderate (Balanced innovation)</option>
                                <option value="creative">Creative (Bold new combinations)</option>
                                <option value="experimental">Experimental (Wild ideas)</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="targetPlatform">Target Platform</label>
                            <select id="targetPlatform">
                                <option value="pc">PC</option>
                                <option value="console">Console</option>
                                <option value="mobile">Mobile</option>
                                <option value="vr">VR</option>
                                <option value="web">Web Browser</option>
                                <option value="multi" selected>Multi-Platform</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="additionalPrompts">Additional Creative Direction (Optional)</label>
                            <textarea id="additionalPrompts" rows="3" placeholder="e.g., 'Make it more family-friendly', 'Add multiplayer elements', 'Set in a cyberpunk world'..."></textarea>
                        </div>

                        <div class="form-actions">
                            <button class="btn btn-success" onclick="generateMoodboard()">
                                <i class="fas fa-palette"></i> Generate Visual Moodboard
                            </button>
                            <button class="btn btn-info" onclick="generatePriceSuggestion()">
                                <i class="fas fa-dollar-sign"></i> Suggest Selling Price
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Generated Content Display -->
            <div id="generatedContent" class="generated-content" style="display: none;">
                <div class="content-section">
                    <h3><i class="fas fa-palette"></i> Visual Moodboard</h3>
                    <div id="moodboardResult" class="moodboard-result">
                        <!-- Moodboard will appear here -->
                    </div>
                </div>

                <div class="content-section" id="pricingSectionContent" style="display: none;">
                    <h3><i class="fas fa-dollar-sign"></i> Suggested Selling Price</h3>
                    <div id="priceSuggestion" class="price-suggestion">
                        <!-- Price suggestions will appear here -->
                    </div>
                </div>

                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="startNewMix()">
                        <i class="fas fa-plus"></i> Create New Mix
                    </button>
                </div>
            </div>

            <!-- Saved Game Ideas -->
            <div class="saved-games-section">
                <h3>Previously Created Game Ideas</h3>
                <div id="gameIdeasList" class="generated-games-grid">
                    <p>No game ideas yet. Create your first game concept above!</p>
                </div>
            </div>

            <!-- Edit Game Idea Form -->
            <div id="editGameIdeaForm" class="form-container" style="display: none;">
                <div class="form-header">
                    <h3>Edit Game Idea</h3>
                    <button class="btn-close" onclick="hideEditGameIdeaForm()">×</button>
                </div>
                <form id="gameIdeaFormElement" onsubmit="updateGameIdea(event)">
                    <input type="hidden" id="editGameIdeaId" value="">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="editGameType">Game Type *</label>
                            <select id="editGameType" required>
                                <option value="">Select Game Type</option>
                                <option value="action">Action</option>
                                <option value="adventure">Adventure</option>
                                <option value="rpg">RPG</option>
                                <option value="strategy">Strategy</option>
                                <option value="puzzle">Puzzle</option>
                                <option value="simulation">Simulation</option>
                                <option value="racing">Racing</option>
                                <option value="horror">Horror</option>
                                <option value="platformer">Platformer</option>
                                <option value="indie">Indie</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="editGameTheme">Game Theme *</label>
                            <select id="editGameTheme" required>
                                <option value="">Select Theme</option>
                                <option value="sci-fi">Sci-Fi</option>
                                <option value="fantasy">Fantasy</option>
                                <option value="medieval">Medieval</option>
                                <option value="modern">Modern</option>
                                <option value="cyberpunk">Cyberpunk</option>
                                <option value="steampunk">Steampunk</option>
                                <option value="post-apocalyptic">Post-Apocalyptic</option>
                                <option value="historical">Historical</option>
                                <option value="space">Space</option>
                                <option value="underwater">Underwater</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="editArtStyle">Art Style *</label>
                            <select id="editArtStyle" required>
                                <option value="">Select Art Style</option>
                                <option value="cartoon">Cartoon</option>
                                <option value="realistic">Realistic</option>
                                <option value="pixel-art">Pixel Art</option>
                                <option value="abstract">Abstract</option>
                                <option value="minimalist">Minimalist</option>
                                <option value="anime">Anime</option>
                                <option value="retro">Retro</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="editTargetPlatform">Target Platform *</label>
                            <select id="editTargetPlatform" required>
                                <option value="">Select Platform</option>
                                <option value="pc">PC</option>
                                <option value="mobile">Mobile</option>
                                <option value="console">Console</option>
                                <option value="web">Web Browser</option>
                                <option value="vr">VR</option>
                                <option value="multi">Multi-Platform</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="editAdditionalPrompts">Additional Prompts</label>
                        <textarea id="editAdditionalPrompts" rows="3" placeholder="Add any specific requirements or ideas..."></textarea>
                    </div>
                    <div class="form-group">
                        <label for="editDescription">Game Description</label>
                        <textarea id="editDescription" rows="4" placeholder="Edit the game description..."></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary">Update Game Idea</button>
                        <button type="button" class="btn btn-secondary" onclick="hideEditGameIdeaForm()">Cancel</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Gesture Generator Page -->
        <div id="gesture-generator" class="page">
            <div class="page-header">
                <h1><i class="fas fa-hand-paper"></i> Gesture-to-Game Generator</h1>
                <p>Use your webcam to create game ideas through hand gestures</p>
            </div>
            
            <div class="gesture-generator-container">
                <div class="generator-card">
                    <div class="card-header">
                        <h3><i class="fas fa-video"></i> Computer Vision Game Creator</h3>
                        <p>Advanced gesture recognition system that converts hand movements into creative game concepts</p>
                    </div>
                    
                    <div class="card-body">
                        <div class="feature-grid">
                            <div class="feature-item">
                                <i class="fas fa-hand-rock"></i>
                                <h4>12+ Gesture Types</h4>
                                <p>Recognizes fist, open palm, thumbs up, peace sign, pointing, and more</p>
                            </div>
                            <div class="feature-item">
                                <i class="fas fa-brain"></i>
                                <h4>AI-Powered Ideas</h4>
                                <p>Uses Gemini 2.0 Flash to generate unique game concepts</p>
                            </div>
                            <div class="feature-item">
                                <i class="fas fa-video-camera"></i>
                                <h4>Real-time Processing</h4>
                                <p>30fps webcam analysis with live gesture detection</p>
                            </div>
                            <div class="feature-item">
                                <i class="fas fa-magic"></i>
                                <h4>Sequence Detection</h4>
                                <p>Combines multiple gestures for complex game mechanics</p>
                            </div>
                        </div>
                        
                        <div class="launch-section">
                            <button id="launch-gesture-generator" class="btn btn-primary btn-large">
                                <i class="fas fa-play"></i> Launch Gesture Generator
                            </button>
                            <p class="launch-info">
                                <i class="fas fa-info-circle"></i>
                                This will open the Python application for gesture recognition
                            </p>
                        </div>
                        
                        <div class="instructions">
                            <h4><i class="fas fa-list"></i> How to Use:</h4>
                            <ol>
                                <li>Click "Launch Gesture Generator" to start the application</li>
                                <li>Allow camera access when prompted</li>
                                <li>Perform hand gestures in front of your webcam</li>
                                <li>Watch as AI generates unique game ideas based on your movements</li>
                                <li>Save your favorite generated game concepts</li>
                            </ol>
                        </div>
                    </div>
                </div>
                
                <!-- Eye Tracking System -->
                <div class="generator-card" style="margin-top: 20px;">
                    <div class="card-header" style="background: linear-gradient(135deg, #667eea, #764ba2);">
                        <h3><i class="fas fa-eye"></i> Multi-Person Eye Tracking System</h3>
                        <p>Advanced biometric monitoring for health and wellness analysis</p>
                    </div>
                    
                    <div class="card-body">
                        <div class="feature-grid">
                            <div class="feature-item">
                                <i class="fas fa-users"></i>
                                <h4>Multi-Person Detection</h4>
                                <p>Track up to 5 people simultaneously with individual health metrics</p>
                            </div>
                            <div class="feature-item">
                                <i class="fas fa-heartbeat"></i>
                                <h4>Health Monitoring</h4>
                                <p>Real-time blink rate analysis with optometric guidelines</p>
                            </div>
                            <div class="feature-item">
                                <i class="fas fa-chart-line"></i>
                                <h4>Data Analytics</h4>
                                <p>Comprehensive statistics and health trend visualization</p>
                            </div>
                            <div class="feature-item">
                                <i class="fas fa-database"></i>
                                <h4>Firebase Integration</h4>
                                <p>Seamless data storage with Gamevibe Arena database</p>
                            </div>
                        </div>
                        
                        <div class="launch-section">
                            <button id="launch-eye-tracker" class="btn btn-primary btn-large">
                                <i class="fas fa-play"></i> Launch Eye Tracker
                            </button>
                            <p class="launch-info">
                                <i class="fas fa-info-circle"></i>
                                Monitor multiple people's eye health and blinking patterns
                            </p>
                        </div>
                        
                        <div class="instructions">
                            <h4><i class="fas fa-list"></i> Eye Tracking Features:</h4>
                            <ol>
                                <li>Real-time face detection for multiple people (Player A, B, C, etc.)</li>
                                <li>Individual blink rate monitoring with health assessment</li>
                                <li>Interactive player name assignment and management</li>
                                <li>Comprehensive data visualization and analytics dashboard</li>
                                <li>Firebase data storage with session recording capabilities</li>
                            </ol>
                            
                            <div style="margin-top: 15px; padding: 10px; background: var(--bg-secondary); border-radius: 5px;">
                                <strong>Health Guidelines:</strong><br>
                                • Healthy: 12-20 blinks/minute<br>
                                • Monitor: 8-12 or 20-25 blinks/minute<br>
                                • Attention Needed: &lt;8 or &gt;25 blinks/minute
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Object Finder Page -->
        <div id="object-finder" class="page">
            <div class="page-header">
                <h1><i class="fas fa-search"></i> Object-Based Game Finder</h1>
                <p>Tell us what objects or elements you want to see in a game, and we'll recommend existing games that feature them!</p>
            </div>

            <!-- Object Input Section -->
            <div class="object-input-container">
                <div class="object-form">
                    <div class="form-group">
                        <label for="objectInput">What objects do you want in your game?</label>
                        <input type="text" id="objectInput" placeholder="e.g., prince, whiteboard, laptop, sword, spaceship..." 
                               onkeypress="handleObjectInput(event)">
                        <small>Press Enter to add each object, or separate with commas</small>
                    </div>
                    
                    <div id="selectedObjects" class="selected-objects">
                        <!-- Selected objects will appear here as tags -->
                    </div>
                    
                    <div class="form-actions">
                        <button class="btn btn-primary" onclick="findGamesByObjects()">
                            <i class="fas fa-search"></i> Find Matching Games
                        </button>
                        <button class="btn btn-secondary" onclick="clearObjects()">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Popular Objects Section -->
            <div class="popular-objects-section">
                <h3><i class="fas fa-fire"></i> Popular Object Categories</h3>
                <div class="object-categories">
                    <div class="category-group">
                        <h4>Fantasy</h4>
                        <div class="quick-objects">
                            <button class="quick-object-btn" onclick="addQuickObject('sword')">Sword</button>
                            <button class="quick-object-btn" onclick="addQuickObject('magic')">Magic</button>
                            <button class="quick-object-btn" onclick="addQuickObject('castle')">Castle</button>
                            <button class="quick-object-btn" onclick="addQuickObject('dragon')">Dragon</button>
                            <button class="quick-object-btn" onclick="addQuickObject('prince')">Prince</button>
                        </div>
                    </div>
                    <div class="category-group">
                        <h4>Modern</h4>
                        <div class="quick-objects">
                            <button class="quick-object-btn" onclick="addQuickObject('laptop')">Laptop</button>
                            <button class="quick-object-btn" onclick="addQuickObject('car')">Car</button>
                            <button class="quick-object-btn" onclick="addQuickObject('phone')">Phone</button>
                            <button class="quick-object-btn" onclick="addQuickObject('gun')">Gun</button>
                            <button class="quick-object-btn" onclick="addQuickObject('city')">City</button>
                        </div>
                    </div>
                    <div class="category-group">
                        <h4>Sci-Fi</h4>
                        <div class="quick-objects">
                            <button class="quick-object-btn" onclick="addQuickObject('spaceship')">Spaceship</button>
                            <button class="quick-object-btn" onclick="addQuickObject('robot')">Robot</button>
                            <button class="quick-object-btn" onclick="addQuickObject('laser')">Laser</button>
                            <button class="quick-object-btn" onclick="addQuickObject('alien')">Alien</button>
                            <button class="quick-object-btn" onclick="addQuickObject('portal')">Portal</button>
                        </div>
                    </div>
                    <div class="category-group">
                        <h4>Nature</h4>
                        <div class="quick-objects">
                            <button class="quick-object-btn" onclick="addQuickObject('tree')">Tree</button>
                            <button class="quick-object-btn" onclick="addQuickObject('animal')">Animal</button>
                            <button class="quick-object-btn" onclick="addQuickObject('water')">Water</button>
                            <button class="quick-object-btn" onclick="addQuickObject('mountain')">Mountain</button>
                            <button class="quick-object-btn" onclick="addQuickObject('farm')">Farm</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Search Results -->
            <div id="objectRecommendations" class="object-recommendations-results" style="display: none;">
                <h3><i class="fas fa-gamepad"></i> Game Recommendations Based on Your Objects</h3>
                <div id="recommendedGames" class="recommended-games-grid">
                    <!-- Recommended games will appear here -->
                </div>
            </div>

            <!-- Search History -->
            <div class="search-history-section">
                <h3><i class="fas fa-history"></i> Recent Searches</h3>
                <div id="searchHistory" class="search-history-list">
                    <p class="no-history">No recent searches yet. Start by searching for objects above!</p>
                </div>
            </div>

            <!-- Saved Recommendations Section -->
            <div class="saved-recommendations-section">
                <h3><i class="fas fa-bookmark"></i> Saved Game Recommendations</h3>
                <div id="savedRecommendationsList" class="saved-recommendations-list">
                    <p>Loading saved recommendations...</p>
                </div>
            </div>

            <!-- Edit Recommendation Form -->
            <div id="editRecommendationForm" class="form-container" style="display: none;">
                <div class="form-header">
                    <h3>Edit Recommendation</h3>
                    <button class="btn-close" onclick="hideEditRecommendationForm()">×</button>
                </div>
                <form id="recommendationFormElement" onsubmit="updateRecommendation(event)">
                    <input type="hidden" id="editRecommendationId" value="">
                    <div class="form-group">
                        <label for="editGameTitle">Game Title *</label>
                        <input type="text" id="editGameTitle" required>
                    </div>
                    <div class="form-group">
                        <label for="editSearchObjects">Search Objects</label>
                        <input type="text" id="editSearchObjects" placeholder="sword, magic, castle" readonly>
                        <small>These were the objects you searched for</small>
                    </div>
                    <div class="form-group">
                        <label for="editNotes">Notes</label>
                        <textarea id="editNotes" rows="3" placeholder="Add your notes about this recommendation..."></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary">Update Recommendation</button>
                        <button type="button" class="btn btn-secondary" onclick="hideEditRecommendationForm()">Cancel</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Users Page -->
        <div id="users" class="page">
            <div class="page-header">
                <h1><i class="fas fa-users"></i> User Management</h1>
                <div class="page-actions">
                    <button class="btn btn-success" onclick="showUserForm()">
                        <i class="fas fa-plus"></i> Add User
                    </button>
                </div>
            </div>

            <!-- User Form -->
            <div id="userForm" class="form-container" style="display: none;">
                <div class="form-header">
                    <h3 id="userFormTitle">Add New User</h3>
                    <button class="btn-close" onclick="hideUserForm()">×</button>
                </div>
                <form id="userFormElement" onsubmit="submitUserForm(event)">
                    <input type="hidden" id="userId" value="">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="userUsername">Username *</label>
                            <input type="text" id="userUsername" required>
                        </div>
                        <div class="form-group">
                            <label for="userEmail">Email *</label>
                            <input type="email" id="userEmail" required>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="userDisplayName">Display Name</label>
                            <input type="text" id="userDisplayName">
                        </div>
                        <div class="form-group">
                            <label for="userRole">Role</label>
                            <select id="userRole">
                                <option value="user">User</option>
                                <option value="moderator">Moderator</option>
                                <option value="admin">Admin</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="userBio">Bio</label>
                        <textarea id="userBio" rows="3"></textarea>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="userLocation">Location</label>
                            <input type="text" id="userLocation">
                        </div>
                        <div class="form-group">
                            <label for="userStatus">Status</label>
                            <select id="userStatus">
                                <option value="active">Active</option>
                                <option value="inactive">Inactive</option>
                                <option value="banned">Banned</option>
                                <option value="suspended">Suspended</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary">
                            <i class="fas fa-save"></i> Save User
                        </button>
                        <button type="button" class="btn btn-secondary" onclick="hideUserForm()">
                            Cancel
                        </button>
                    </div>
                </form>
            </div>

            <div class="content-filters">
                <input type="text" id="usersSearch" placeholder="Search users..." class="search-input">
                <button onclick="filterUsers()">Search</button>
            </div>

            <div class="users-list" id="usersList">
                <p>Loading users...</p>
            </div>
        </div>

        <div id="leaderboard" class="page">
            <div class="page-header">
                <h1><i class="fas fa-trophy"></i> Moodboard Leaderboard</h1>
                <p>Vote for the best AI-generated game moodboards created by the community!</p>
            </div>

            <!-- Voting Stats -->
            <div class="leaderboard-stats">
                <div class="stat-card">
                    <i class="fas fa-palette stat-icon"></i>
                    <span class="stat-number" id="totalMoodboards">0</span>
                    <span class="stat-label">Total Moodboards</span>
                </div>
                <div class="stat-card">
                    <i class="fas fa-thumbs-up stat-icon"></i>
                    <span class="stat-number" id="totalVotes">0</span>
                    <span class="stat-label">Total Votes Cast</span>
                </div>
            </div>

            <!-- Filter Options -->
            <div class="leaderboard-controls">
                <div class="control-group">
                    <label for="sortBy">Sort by:</label>
                    <select id="sortBy" onchange="loadLeaderboard()">
                        <option value="votes">Most Votes</option>
                        <option value="recent">Most Recent</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="filterTheme">Filter by Theme:</label>
                    <select id="filterTheme" onchange="loadLeaderboard()">
                        <option value="">All Themes</option>
                        <option value="sci-fi">Sci-Fi</option>
                        <option value="fantasy">Fantasy</option>
                        <option value="medieval">Medieval</option>
                        <option value="modern">Modern</option>
                        <option value="cyberpunk">Cyberpunk</option>
                        <option value="steampunk">Steampunk</option>
                        <option value="post-apocalyptic">Post-Apocalyptic</option>
                        <option value="historical">Historical</option>
                        <option value="space">Space</option>
                        <option value="underwater">Underwater</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="filterType">Filter by Type:</label>
                    <select id="filterType" onchange="loadLeaderboard()">
                        <option value="">All Types</option>
                        <option value="action">Action</option>
                        <option value="adventure">Adventure</option>
                        <option value="rpg">RPG</option>
                        <option value="strategy">Strategy</option>
                        <option value="puzzle">Puzzle</option>
                        <option value="simulation">Simulation</option>
                        <option value="racing">Racing</option>
                        <option value="horror">Horror</option>
                        <option value="platformer">Platformer</option>
                        <option value="indie">Indie</option>
                    </select>
                </div>
            </div>

            <!-- Leaderboard Content -->
            <div class="leaderboard-content" id="leaderboardContent">
                <p>Loading leaderboard...</p>
            </div>
        </div>
    </main>

    <script>
        // Firebase configuration - SAME AS YOUR WORKING simple-crud-test
        const firebaseConfig = {
            apiKey: "AIzaSyDs85pi4hcRqtFUg-mrNgci9aWPV1pUI_M",
            authDomain: "c290-constellation-of-kindness.firebaseapp.com",
            projectId: "c290-constellation-of-kindness",
            storageBucket: "c290-constellation-of-kindness.firebasestorage.app",
            messagingSenderId: "908459397825",
            appId: "1:908459397825:web:8aced5a815a902aac5fa40"
        };

        // Initialize Firebase - SAME PATTERN AS WORKING simple-crud-test
        let app, db;

        async function initFirebase() {
            try {
                console.log('Initializing Firebase...');
                app = firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                
                // Test connection
                await db.collection('users').limit(1).get();
                console.log('✅ Firebase connected successfully!');
                return true;
            } catch (error) {
                console.error('❌ Firebase error:', error.message);
                return false;
            }
        }

        // Navigation
        function showPage(pageId) {
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            
            // Remove active from nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            // Show selected page
            document.getElementById(pageId).classList.add('active');
            document.querySelector(`[data-page="${pageId}"]`).classList.add('active');
            
            // Load page data
            loadPageData(pageId);
        }

        async function loadPageData(pageId) {
            switch(pageId) {
                case 'dashboard':
                    await refreshStats();
                    break;
                case 'games':
                    await loadGames();
                    break;
                case 'game-ideas':
                    await loadGameIdeas();
                    break;
                case 'object-finder':
                    // Load saved recommendations and search history
                    await loadSavedRecommendations();
                    loadSearchHistory();
                    loadSearchHistory();
                    break;
                case 'users':
                    await loadUsers();
                    break;
                case 'leaderboard':
                    await loadLeaderboard();
                    break;
            }
        }

        // CRUD Operations - USING SAME DIRECT FIREBASE PATTERN

        // 1. USERS CRUD
        async function loadUsers() {
            try {
                const snapshot = await db.collection('users').get();
                const users = [];
                
                snapshot.forEach(doc => {
                    users.push({ id: doc.id, ...doc.data() });
                });

                const html = users.length > 0 
                    ? users.map(user => `
                        <div class="user-card">
                            <h3>${user.username || user.displayName || 'Unknown User'}</h3>
                            <p><strong>Email:</strong> ${user.email || 'No email'}</p>
                            <p><strong>Role:</strong> ${user.role || 'user'}</p>
                            <p><strong>Status:</strong> ${user.status || 'active'}</p>
                            <p><strong>Created:</strong> ${user.createdAt || 'Unknown'}</p>
                            <div class="card-actions">
                                <button onclick="showUserForm('${user.id}')" class="btn btn-sm btn-primary">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                                <button onclick="deleteUser('${user.id}')" class="btn btn-sm btn-danger">
                                    <i class="fas fa-trash"></i> Delete
                                </button>
                            </div>
                        </div>
                    `).join('')
                    : '<p>No users found</p>';

                document.getElementById('usersList').innerHTML = html;
                console.log(`✅ Loaded ${users.length} users`);
                
            } catch (error) {
                console.error('❌ Error loading users:', error);
                document.getElementById('usersList').innerHTML = `<p>Loading users...</p>`;
            }
        }

        async function addSampleUser() {
            try {
                const userData = {
                    username: `user_${Date.now()}`,
                    email: `user${Date.now()}@example.com`,
                    displayName: `Test User ${Date.now()}`,
                    role: 'user',
                    isActive: true,
                    createdAt: new Date().toISOString()
                };

                const docRef = await db.collection('users').add(userData);
                console.log(`✅ User added with ID: ${docRef.id}`);
                await loadUsers();
                
            } catch (error) {
                console.error('❌ Error adding user:', error);
            }
        }

        async function deleteUser(userId) {
            if (confirm('Are you sure you want to delete this user?')) {
                try {
                    await db.collection('users').doc(userId).delete();
                    console.log(`✅ User deleted: ${userId}`);
                    showNotification('User deleted successfully!', 'success');
                    await loadUsers();
                    await refreshStats(); // Update dashboard stats
                } catch (error) {
                    console.error('❌ Error deleting user:', error);
                    showNotification('Error deleting user: ' + error.message, 'error');
                }
            }
        }

        // 2. GAMES CRUD
        async function loadGames() {
            try {
                const snapshot = await db.collection('games').get();
                const games = [];
                
                snapshot.forEach(doc => {
                    games.push({ id: doc.id, ...doc.data() });
                });

                const html = games.length > 0 
                    ? games.map(game => `
                        <div class="game-card">
                            <h3>${game.title || 'Untitled Game'}</h3>
                            <p><strong>Developer:</strong> ${game.developer || 'Unknown'}</p>
                            <p><strong>Genre:</strong> ${Array.isArray(game.genre) ? game.genre.join(', ') : game.genre || 'Unknown'}</p>
                            <p><strong>Platform:</strong> ${Array.isArray(game.platform) ? game.platform.join(', ') : game.platform || 'Unknown'}</p>
                            <p><strong>Status:</strong> ${game.status || 'available'}</p>
                            <p><strong>Created:</strong> ${game.createdAt || 'Unknown'}</p>
                            <div class="card-actions">
                                <button onclick="showGameForm('${game.id}')" class="btn btn-sm btn-primary">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                                <button onclick="deleteGame('${game.id}')" class="btn btn-sm btn-danger">
                                    <i class="fas fa-trash"></i> Delete
                                </button>
                            </div>
                        </div>
                    `).join('')
                    : '<p>No games found</p>';

                document.getElementById('gamesGrid').innerHTML = html;
                console.log(`✅ Loaded ${games.length} games`);
                
            } catch (error) {
                console.error('❌ Error loading games:', error);
                document.getElementById('gamesGrid').innerHTML = `<p>Loading games...</p>`;
            }
        }

        async function addSampleGame() {
            try {
                const gameData = {
                    title: `Test Game ${Date.now()}`,
                    developer: 'Test Developer',
                    genre: ['Action', 'Adventure'],
                    platform: ['PC', 'Console'],
                    description: 'A test game for demonstration',
                    status: 'available',
                    createdAt: new Date().toISOString()
                };

                const docRef = await db.collection('games').add(gameData);
                console.log(`✅ Game added with ID: ${docRef.id}`);
                await loadGames();
                
            } catch (error) {
                console.error('❌ Error adding game:', error);
            }
        }

        async function deleteGame(gameId) {
            if (confirm('Are you sure you want to delete this game?')) {
                try {
                    await db.collection('games').doc(gameId).delete();
                    console.log(`✅ Game deleted: ${gameId}`);
                    showNotification('Game deleted successfully!', 'success');
                    await loadGames();
                    await refreshStats(); // Update dashboard stats
                } catch (error) {
                    console.error('❌ Error deleting game:', error);
                    showNotification('Error deleting game: ' + error.message, 'error');
                }
            }
        }

        // 3. REVIEWS CRUD
        async function loadReviews() {
            try {
                const snapshot = await db.collection('reviews').get();
                const reviews = [];
                
                snapshot.forEach(doc => {
                    reviews.push({ id: doc.id, ...doc.data() });
                });

                const html = reviews.length > 0 
                    ? reviews.map(review => `
                        <div class="review-card">
                            <h4>${review.title || 'Untitled Review'}</h4>
                            <p><strong>Rating:</strong> ${'★'.repeat(review.rating || 0)}${'☆'.repeat(5 - (review.rating || 0))}</p>
                            <p><strong>Content:</strong> ${review.content || 'No content'}</p>
                            <p><strong>Game ID:</strong> ${review.gameId || 'Unknown'}</p>
                            <p><strong>User ID:</strong> ${review.userId || 'Unknown'}</p>
                            <p><strong>Recommended:</strong> ${review.recommended ? 'Yes' : 'No'}</p>
                            <p><strong>Created:</strong> ${review.createdAt || 'Unknown'}</p>
                            <div class="card-actions">
                                <button onclick="showReviewForm('${review.id}')" class="btn btn-sm btn-primary">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                                <button onclick="deleteReview('${review.id}')" class="btn btn-sm btn-danger">
                                    <i class="fas fa-trash"></i> Delete
                                </button>
                            </div>
                        </div>
                    `).join('')
                    : '<p>No reviews found</p>';

                document.getElementById('reviewsList').innerHTML = html;
                console.log(`✅ Loaded ${reviews.length} reviews`);
                
            } catch (error) {
                console.error('❌ Error loading reviews:', error);
                document.getElementById('reviewsList').innerHTML = `<p>Loading reviews...</p>`;
            }
        }

        async function addSampleReview() {
            try {
                // Get a random game and user
                const gameSnapshot = await db.collection('games').limit(1).get();
                const userSnapshot = await db.collection('users').limit(1).get();
                
                if (gameSnapshot.empty || userSnapshot.empty) {
                    console.log('Need at least one game and one user to create a review');
                    return;
                }

                const gameId = gameSnapshot.docs[0].id;
                const userId = userSnapshot.docs[0].id;

                const reviewData = {
                    gameId: gameId,
                    userId: userId,
                    rating: Math.floor(Math.random() * 5) + 1,
                    title: `Great game review ${Date.now()}`,
                    content: 'This is a sample review for testing purposes.',
                    moderationStatus: 'approved',
                    helpful: 0,
                    notHelpful: 0,
                    createdAt: new Date().toISOString()
                };

                const docRef = await db.collection('reviews').add(reviewData);
                console.log(`✅ Review added with ID: ${docRef.id}`);
                await loadReviews();
                
            } catch (error) {
                console.error('❌ Error adding review:', error);
            }
        }

        async function deleteReview(reviewId) {
            if (confirm('Are you sure you want to delete this review?')) {
                try {
                    await db.collection('reviews').doc(reviewId).delete();
                    console.log(`✅ Review deleted: ${reviewId}`);
                    showNotification('Review deleted successfully!', 'success');
                    await loadReviews();
                    await refreshStats(); // Update dashboard stats
                } catch (error) {
                    console.error('❌ Error deleting review:', error);
                    showNotification('Error deleting review: ' + error.message, 'error');
                }
            }
        }

        // 4. RECOMMENDATIONS CRUD
        async function loadRecommendations() {
            try {
                const snapshot = await db.collection('recommendations').get();
                const recommendations = [];
                
                snapshot.forEach(doc => {
                    recommendations.push({ id: doc.id, ...doc.data() });
                });

                const html = recommendations.length > 0 
                    ? recommendations.map(rec => `
                        <div class="recommendation-card">
                            <h4>Recommendation for User: ${rec.userId || 'Unknown'}</h4>
                            <p><strong>Algorithm:</strong> ${rec.algorithm || 'Unknown'}</p>
                            <p><strong>Category:</strong> ${rec.category || 'general'}</p>
                            <p><strong>Score:</strong> ${rec.score || 'N/A'}</p>
                            <p><strong>Reason:</strong> ${rec.reason || 'No reason provided'}</p>
                            <p><strong>Generated:</strong> ${rec.generatedAt || 'Unknown'}</p>
                            <p><strong>Items:</strong> ${rec.recommendations ? rec.recommendations.length : 0}</p>
                            <div class="card-actions">
                                <button onclick="showRecommendationForm('${rec.id}')" class="btn btn-sm btn-primary">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                                <button onclick="deleteRecommendation('${rec.id}')" class="btn btn-sm btn-danger">
                                    <i class="fas fa-trash"></i> Delete
                                </button>
                            </div>
                        </div>
                    `).join('')
                    : '<p>No recommendations found</p>';

                document.getElementById('recommendationsContent').innerHTML = html;
                console.log(`✅ Loaded ${recommendations.length} recommendations`);
                
            } catch (error) {
                console.error('❌ Error loading recommendations:', error);
                document.getElementById('recommendationsContent').innerHTML = `<p>Loading recommendations...</p>`;
            }
        }

        async function addSampleRecommendation() {
            try {
                // Get a random user
                const userSnapshot = await db.collection('users').limit(1).get();
                
                if (userSnapshot.empty) {
                    console.log('Need at least one user to create recommendations');
                    return;
                }

                const userId = userSnapshot.docs[0].id;

                const recommendationData = {
                    userId: userId,
                    algorithm: 'content_based',
                    generatedAt: new Date().toISOString(),
                    isViewed: false,
                    recommendations: [
                        {
                            gameId: 'sample_game_1',
                            score: 0.95,
                            reasons: ['High rating', 'Similar genre', 'Popular choice']
                        },
                        {
                            gameId: 'sample_game_2', 
                            score: 0.87,
                            reasons: ['Matches preferences', 'Recently trending']
                        }
                    ],
                    preferences: {
                        favoriteGenres: ['Action', 'RPG'],
                        minRating: 4.0
                    },
                    createdAt: new Date().toISOString()
                };

                const docRef = await db.collection('recommendations').add(recommendationData);
                console.log(`✅ Recommendation added with ID: ${docRef.id}`);
                await loadRecommendations();
                
            } catch (error) {
                console.error('❌ Error adding recommendation:', error);
            }
        }

        async function deleteRecommendation(recId) {
            if (confirm('Are you sure you want to delete this recommendation?')) {
                try {
                    await db.collection('recommendations').doc(recId).delete();
                    console.log(`✅ Recommendation deleted: ${recId}`);
                    showNotification('Recommendation deleted successfully!', 'success');
                    await loadRecommendations();
                    await refreshStats(); // Update dashboard stats
                } catch (error) {
                    console.error('❌ Error deleting recommendation:', error);
                    showNotification('Error deleting recommendation: ' + error.message, 'error');
                }
            }
        }

        // 5. TAGS CRUD
        async function loadTags() {
            try {
                const snapshot = await db.collection('tags').get();
                const tags = [];
                
                snapshot.forEach(doc => {
                    tags.push({ id: doc.id, ...doc.data() });
                });

                const html = tags.length > 0 
                    ? tags.map(tag => `
                        <div class="tag-card">
                            <h4>${tag.name || 'Unnamed Tag'}</h4>
                            <p><strong>Category:</strong> ${tag.type || 'other'}</p>
                            <p><strong>Description:</strong> ${tag.description || 'No description'}</p>
                            <p><strong>Color:</strong> <span style="background: ${tag.color || '#ccc'}; color: white; padding: 2px 8px; border-radius: 3px;">${tag.color || '#ccc'}</span></p>
                            <p><strong>Active:</strong> ${tag.isActive ? 'Yes' : 'No'}</p>
                            <p><strong>Game Count:</strong> ${tag.gameCount || 0}</p>
                            <div class="card-actions">
                                <button onclick="showTagForm('${tag.id}')" class="btn btn-sm btn-primary">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                                <button onclick="deleteTag('${tag.id}')" class="btn btn-sm btn-danger">
                                    <i class="fas fa-trash"></i> Delete
                                </button>
                            </div>
                        </div>
                    `).join('')
                    : '<p>No tags found</p>';

                document.getElementById('tagsGrid').innerHTML = html;
                console.log(`✅ Loaded ${tags.length} tags`);
                
            } catch (error) {
                console.error('❌ Error loading tags:', error);
                document.getElementById('tagsGrid').innerHTML = `<p>Loading tags...</p>`;
            }
        }

        async function addSampleTag() {
            try {
                const tagTypes = ['genre', 'category', 'feature', 'status'];
                const tagNames = ['Action', 'Adventure', 'RPG', 'Strategy', 'Indie', 'Multiplayer', 'Singleplayer', 'Early Access'];
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
                
                const tagData = {
                    name: `${tagNames[Math.floor(Math.random() * tagNames.length)]}_${Date.now()}`,
                    type: tagTypes[Math.floor(Math.random() * tagTypes.length)],
                    color: colors[Math.floor(Math.random() * colors.length)],
                    description: 'Sample tag for testing',
                    isActive: true,
                    gameCount: 0,
                    createdBy: null,
                    createdAt: new Date().toISOString()
                };

                const docRef = await db.collection('tags').add(tagData);
                console.log(`✅ Tag added with ID: ${docRef.id}`);
                await loadTags();
                
            } catch (error) {
                console.error('❌ Error adding tag:', error);
            }
        }

        async function deleteTag(tagId) {
            if (confirm('Are you sure you want to delete this tag?')) {
                try {
                    await db.collection('tags').doc(tagId).delete();
                    console.log(`✅ Tag deleted: ${tagId}`);
                    showNotification('Tag deleted successfully!', 'success');
                    await loadTags();
                    await refreshStats(); // Update dashboard stats
                } catch (error) {
                    console.error('❌ Error deleting tag:', error);
                    showNotification('Error deleting tag: ' + error.message, 'error');
                }
            }
        }

        // 6. MODERATION LOGS CRUD
        async function loadModerationLogs() {
            try {
                const snapshot = await db.collection('moderationLogs').get();
                const logs = [];
                
                snapshot.forEach(doc => {
                    logs.push({ id: doc.id, ...doc.data() });
                });

                const html = logs.length > 0 
                    ? logs.map(log => `
                        <div class="log-card">
                            <h4>${log.action || 'Unknown Action'}</h4>
                            <p><strong>Target:</strong> ${log.targetType || 'Unknown'} (${log.targetId || 'Unknown'})</p>
                            <p><strong>Moderator:</strong> ${log.moderatorId || 'System'}</p>
                            <p><strong>Reason:</strong> ${log.reason || 'No reason provided'}</p>
                            <p><strong>Severity:</strong> ${log.severity || 'medium'}</p>
                            <p><strong>Status:</strong> ${log.status || 'active'}</p>
                            <p><strong>Timestamp:</strong> ${log.timestamp || log.createdAt || 'Unknown'}</p>
                            <p><strong>Flagged:</strong> ${log.flagged ? 'Yes' : 'No'}</p>
                            <div class="card-actions">
                                <button onclick="showModerationForm('${log.id}')" class="btn btn-sm btn-primary">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                                <button onclick="deleteLog('${log.id}')" class="btn btn-sm btn-danger">
                                    <i class="fas fa-trash"></i> Delete
                                </button>
                            </div>
                        </div>
                    `).join('')
                    : '<p>No logs found</p>';

                document.getElementById('logsList').innerHTML = html;
                console.log(`✅ Loaded ${logs.length} logs`);
                
            } catch (error) {
                console.error('❌ Error loading logs:', error);
                document.getElementById('logsList').innerHTML = `<p>Loading logs...</p>`;
            }
        }

        async function addSampleModerationLog() {
            try {
                const actions = ['user_login', 'review_posted', 'game_added', 'sentiment_analysis', 'content_flagged'];
                const sentiments = ['positive', 'neutral', 'negative'];
                
                const logData = {
                    timestamp: new Date().toISOString(),
                    action: actions[Math.floor(Math.random() * actions.length)],
                    sentiment: sentiments[Math.floor(Math.random() * sentiments.length)],
                    flagged: Math.random() > 0.8, // 20% chance of being flagged
                    threshold: Math.random(),
                    mood: Math.random() > 0.5 ? 'happy' : 'neutral',
                    analyzed: true,
                    userId: 'sample_user_id',
                    details: {
                        source: 'automated_test',
                        confidence: Math.random()
                    },
                    createdAt: new Date().toISOString()
                };

                const docRef = await db.collection('moderationLogs').add(logData);
                console.log(`✅ Moderation log added with ID: ${docRef.id}`);
                await loadModerationLogs();
                
            } catch (error) {
                console.error('❌ Error adding moderation log:', error);
            }
        }

        async function deleteLog(logId) {
            if (confirm('Are you sure you want to delete this moderation log?')) {
                try {
                    await db.collection('moderationLogs').doc(logId).delete();
                    console.log(`✅ Log deleted: ${logId}`);
                    showNotification('Moderation log deleted successfully!', 'success');
                    await loadModerationLogs();
                    await refreshStats(); // Update dashboard stats
                } catch (error) {
                    console.error('❌ Error deleting log:', error);
                    showNotification('Error deleting log: ' + error.message, 'error');
                }
            }
        }

        // Dashboard Stats
        async function refreshStats() {
            try {
                const collections = ['users', 'games', 'gameIdeas', 'savedRecommendations'];
                const stats = {};
                
                // Count documents in each collection
                for (const collection of collections) {
                    try {
                        const snapshot = await db.collection(collection).get();
                        stats[collection] = snapshot.size;
                    } catch (collectionError) {
                        console.log(`Collection ${collection} not found, setting to 0`);
                        stats[collection] = 0;
                    }
                }
                
                // Count moodboards on leaderboard (public gameIdeas only)
                try {
                    const moodboardSnapshot = await db.collection('gameIdeas')
                        .where('isPublic', '==', true)
                        .get();
                    stats.moodboards = moodboardSnapshot.size;
                } catch (moodboardError) {
                    console.log('No public moodboards found, using total gameIdeas count');
                    stats.moodboards = stats.gameIdeas || 0;
                }
                
                // Update dashboard stats with proper error handling
                const updateStat = (elementId, value) => {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.textContent = value || 0;
                    }
                };
                
                updateStat('statsGames', stats.games);
                updateStat('statsGameIdeas', stats.gameIdeas);
                updateStat('statsObjectSearches', stats.savedRecommendations); // Object searches are saved as recommendations
                updateStat('statsUsers', stats.users);
                updateStat('statsMoodboards', stats.moodboards);
                
                console.log('✅ Stats updated:', stats);
                
            } catch (error) {
                console.error('❌ Error refreshing stats:', error);
                // Set default values on error
                const defaultStats = ['statsGames', 'statsGameIdeas', 'statsObjectSearches', 'statsUsers', 'statsMoodboards'];
                defaultStats.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = '0';
                });
            }
        }

        // CHEAPSHARK API INTEGRATION
        
        function showGameBrowser() {
            document.getElementById('gameBrowser').style.display = 'block';
            // Automatically load popular games when browser opens
            loadPopularGames();
        }

        function hideGameBrowser() {
            document.getElementById('gameBrowser').style.display = 'none';
        }

        async function loadPopularGames() {
            const resultsDiv = document.getElementById('apiSearchResults');
            resultsDiv.innerHTML = '<p class="text-center"><i class="fas fa-spinner fa-spin"></i> Loading popular games...</p>';

            try {
                // Get deals sorted by metacritic score to find popular games
                const response = await fetch('https://www.cheapshark.com/api/1.0/deals?sortBy=Metacritic&desc=1&pageSize=20');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const deals = await response.json();
                
                // Convert deals to games format for display
                const games = deals.map(deal => ({
                    gameID: deal.gameID,
                    external: deal.title,
                    thumb: deal.thumb,
                    metacriticScore: deal.metacriticScore,
                    steamRating: deal.steamRatingPercent,
                    cheapest: deal.salePrice,
                    cheapestDealID: deal.dealID
                }));
                
                displayCheapSharkResults(games);
                
            } catch (error) {
                console.error('Error fetching popular games:', error);
                resultsDiv.innerHTML = `<p class="text-center">Loading games...</p>`;
            }
        }

        function displayCheapSharkResults(games) {
            const resultsDiv = document.getElementById('apiSearchResults');
            
            if (!games || games.length === 0) {
                resultsDiv.innerHTML = '<p class="text-center">No games found</p>';
                return;
            }

            const html = `
                <div class="api-games-grid">
                    ${games.map(game => `
                        <div class="api-game-card">
                            <div class="game-thumb">
                                <img src="${game.thumb || 'https://via.placeholder.com/150x200?text=No+Image'}" 
                                     alt="${game.external}" 
                                     onerror="this.src='https://via.placeholder.com/150x200?text=No+Image'">
                            </div>
                            <div class="game-info">
                                <h4>${game.external}</h4>
                                ${game.metacriticScore ? `<p><strong>Metacritic:</strong> ${game.metacriticScore}/100</p>` : ''}
                                ${game.steamRating ? `<p><strong>Steam Rating:</strong> ${game.steamRating}%</p>` : ''}
                                ${game.cheapest ? `<p><strong>Lowest Price:</strong> $${game.cheapest}</p>` : ''}
                                <button class="btn btn-sm btn-success" onclick="addGameFromAPI('${game.gameID}', '${game.external.replace(/'/g, "\\'")}')">
                                    <i class="fas fa-plus"></i> Add to Library
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;

            resultsDiv.innerHTML = html;
        }

        async function addGameFromAPI(gameID, title) {
            try {
                // Get detailed game info
                const response = await fetch(`https://www.cheapshark.com/api/1.0/games?id=${gameID}`);
                const gameDetails = await response.json();
                
                if (!gameDetails || !gameDetails.info) {
                    throw new Error('Could not fetch game details');
                }

                const info = gameDetails.info;
                
                // Prepare game data for Firebase
                const gameData = {
                    title: info.title || title,
                    developer: extractDeveloper(info.title) || 'Unknown Developer',
                    genre: ['Unknown'], // CheapShark doesn't provide genre info
                    platform: ['PC'], // CheapShark is primarily PC games
                    description: `Game sourced from CheapShark API. Steam App ID: ${info.steamAppID || 'Unknown'}`,
                    status: 'available',
                    steamAppID: info.steamAppID || null,
                    thumb: info.thumb || null,
                    cheapSharkID: gameID,
                    createdAt: new Date().toISOString(),
                    addedFrom: 'cheapshark_api'
                };

                // Add to Firebase
                const docRef = await db.collection('games').add(gameData);
                console.log(`✅ Game added from API with ID: ${docRef.id}`);
                
                // Show success message
                showNotification(`Game "${gameData.title}" added to library!`, 'success');
                
                // Refresh the games list
                await loadGames();
                await refreshStats();
                
            } catch (error) {
                console.error('❌ Error adding game from API:', error);
                showNotification('Error adding game: ' + error.message, 'error');
            }
        }

        function extractDeveloper(title) {
            // Simple extraction - in real app you might want to use Steam API for better data
            const patterns = [
                /by\s+([^-\(]+)/i,
                /from\s+([^-\(]+)/i,
                /-\s*([^-\(]+)$/
            ];
            
            for (const pattern of patterns) {
                const match = title.match(pattern);
                if (match && match[1]) {
                    return match[1].trim();
                }
            }
            
            return null;
        }

        // Notification system
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-message">${message}</span>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">&times;</button>
                </div>
            `;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }

        // FORM FUNCTIONS FOR ALL COLLECTIONS

        // 1. GAME FORM FUNCTIONS
        function showGameForm(gameId = null) {
            const form = document.getElementById('gameForm');
            const formTitle = document.getElementById('gameFormTitle');
            const formElement = document.getElementById('gameFormElement');
            
            form.style.display = 'block';
            formElement.reset();
            
            if (gameId) {
                formTitle.textContent = 'Edit Game';
                document.getElementById('gameId').value = gameId;
                // Load game data for editing
                loadGameForEdit(gameId);
            } else {
                formTitle.textContent = 'Add New Game';
                document.getElementById('gameId').value = '';
            }
        }

        function hideGameForm() {
            document.getElementById('gameForm').style.display = 'none';
        }

        async function submitGameForm(event) {
            event.preventDefault();
            
            console.log('🔄 Form submission started...'); // Debug log
            
            const gameId = document.getElementById('gameId').value;
            const formData = {
                title: document.getElementById('gameTitle').value,
                developer: document.getElementById('gameDeveloper').value,
                genre: document.getElementById('gameGenre').value.split(',').map(g => g.trim()).filter(g => g),
                platform: document.getElementById('gamePlatform').value.split(',').map(p => p.trim()).filter(p => p),
                description: document.getElementById('gameDescription').value,
                status: document.getElementById('gameStatus').value,
                updatedAt: new Date().toISOString()
            };

            if (!gameId) {
                formData.createdAt = new Date().toISOString();
            }

            console.log('📝 Form data:', formData); // Debug log

            try {
                let docRef;
                if (gameId) {
                    await db.collection('games').doc(gameId).update(formData);
                    console.log('✅ Game updated successfully');
                    alert('Game updated successfully!');
                } else {
                    docRef = await db.collection('games').add(formData);
                    console.log('✅ Game added successfully with ID:', docRef.id);
                    alert('Game added successfully!');
                }
                
                hideGameForm();
                await loadGames();
                await refreshStats(); // Update dashboard stats
            } catch (error) {
                console.error('❌ Error saving game:', error);
                alert('Error saving game: ' + error.message);
            }
        }

        // 2. REVIEW FORM FUNCTIONS
        function showReviewForm(reviewId = null) {
            const form = document.getElementById('reviewForm');
            const formTitle = document.getElementById('reviewFormTitle');
            const formElement = document.getElementById('reviewFormElement');
            
            form.style.display = 'block';
            formElement.reset();
            
            if (reviewId) {
                formTitle.textContent = 'Edit Review';
                document.getElementById('reviewId').value = reviewId;
                loadReviewForEdit(reviewId);
            } else {
                formTitle.textContent = 'Add New Review';
                document.getElementById('reviewId').value = '';
            }
        }

        function hideReviewForm() {
            document.getElementById('reviewForm').style.display = 'none';
        }

        async function submitReviewForm(event) {
            event.preventDefault();
            
            const reviewId = document.getElementById('reviewId').value;
            const formData = {
                gameId: document.getElementById('reviewGameId').value,
                userId: document.getElementById('reviewUserId').value,
                rating: parseInt(document.getElementById('reviewRating').value),
                title: document.getElementById('reviewTitle').value,
                content: document.getElementById('reviewText').value,
                recommended: document.getElementById('reviewRecommended').value === 'true',
                moderationStatus: 'pending',
                helpful: 0,
                notHelpful: 0,
                updatedAt: new Date().toISOString()
            };

            if (!reviewId) {
                formData.createdAt = new Date().toISOString();
            }

            try {
                let docRef;
                if (reviewId) {
                    await db.collection('reviews').doc(reviewId).update(formData);
                    console.log('✅ Review updated successfully');
                    showNotification('Review updated successfully!', 'success');
                } else {
                    docRef = await db.collection('reviews').add(formData);
                    console.log('✅ Review added successfully with ID:', docRef.id);
                    showNotification('Review added successfully!', 'success');
                }
                
                hideReviewForm();
                await loadReviews();
                await refreshStats(); // Update dashboard stats
            } catch (error) {
                console.error('❌ Error saving review:', error);
                showNotification('Error saving review: ' + error.message, 'error');
            }
        }

        // 3. RECOMMENDATION FORM FUNCTIONS
        function showRecommendationForm(recId = null) {
            const form = document.getElementById('recommendationForm');
            const formTitle = document.getElementById('recommendationFormTitle');
            const formElement = document.getElementById('recommendationFormElement');
            
            form.style.display = 'block';
            formElement.reset();
            
            if (recId) {
                formTitle.textContent = 'Edit Recommendation';
                document.getElementById('recommendationId').value = recId;
                loadRecommendationForEdit(recId);
            } else {
                formTitle.textContent = 'Add New Recommendation';
                document.getElementById('recommendationId').value = '';
            }
        }

        function hideRecommendationForm() {
            document.getElementById('recommendationForm').style.display = 'none';
        }

        async function submitRecommendationForm(event) {
            event.preventDefault();
            
            const recId = document.getElementById('recommendationId').value;
            const formData = {
                userId: document.getElementById('recommendationUserId').value,
                gameId: document.getElementById('recommendationGameId').value,
                reason: document.getElementById('recommendationReason').value,
                score: parseFloat(document.getElementById('recommendationScore').value),
                description: document.getElementById('recommendationDescription').value,
                category: document.getElementById('recommendationCategory').value,
                status: document.getElementById('recommendationStatus').value,
                algorithm: 'manual',
                isViewed: false,
                generatedAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            if (!recId) {
                formData.createdAt = new Date().toISOString();
            }

            try {
                let docRef;
                if (recId) {
                    await db.collection('recommendations').doc(recId).update(formData);
                    console.log('✅ Recommendation updated successfully');
                    showNotification('Recommendation updated successfully!', 'success');
                } else {
                    docRef = await db.collection('recommendations').add(formData);
                    console.log('✅ Recommendation added successfully with ID:', docRef.id);
                    showNotification('Recommendation added successfully!', 'success');
                }
                
                hideRecommendationForm();
                await loadRecommendations();
                await refreshStats(); // Update dashboard stats
            } catch (error) {
                console.error('❌ Error saving recommendation:', error);
                showNotification('Error saving recommendation: ' + error.message, 'error');
            }
        }

        // 4. USER FORM FUNCTIONS
        function showUserForm(userId = null) {
            const form = document.getElementById('userForm');
            const formTitle = document.getElementById('userFormTitle');
            const formElement = document.getElementById('userFormElement');
            
            form.style.display = 'block';
            formElement.reset();
            
            if (userId) {
                formTitle.textContent = 'Edit User';
                loadUserForEdit(userId);
            } else {
                formTitle.textContent = 'Add New User';
                document.getElementById('userId').value = '';
            }
        }

        function hideUserForm() {
            document.getElementById('userForm').style.display = 'none';
        }

        async function loadUserForEdit(userId) {
            try {
                const doc = await db.collection('users').doc(userId).get();
                if (doc.exists) {
                    const userData = doc.data();
                    document.getElementById('userId').value = userId;
                    document.getElementById('userUsername').value = userData.username || '';
                    document.getElementById('userEmail').value = userData.email || '';
                    document.getElementById('userDisplayName').value = userData.displayName || '';
                    document.getElementById('userRole').value = userData.role || 'user';
                    document.getElementById('userBio').value = userData.bio || '';
                    document.getElementById('userLocation').value = userData.location || '';
                    document.getElementById('userStatus').value = userData.status || 'active';
                }
            } catch (error) {
                console.error('❌ Error loading user for edit:', error);
                showNotification('Loading user data...', 'info');
            }
        }

        async function submitUserForm(event) {
            event.preventDefault();
            
            const userId = document.getElementById('userId').value;
            const formData = {
                username: document.getElementById('userUsername').value,
                email: document.getElementById('userEmail').value,
                displayName: document.getElementById('userDisplayName').value,
                role: document.getElementById('userRole').value,
                bio: document.getElementById('userBio').value,
                location: document.getElementById('userLocation').value,
                status: document.getElementById('userStatus').value,
                isActive: document.getElementById('userStatus').value === 'active',
                updatedAt: new Date().toISOString()
            };

            if (!userId) {
                formData.createdAt = new Date().toISOString();
            }

            try {
                let docRef;
                if (userId) {
                    await db.collection('users').doc(userId).update(formData);
                    console.log('✅ User updated successfully');
                    showNotification('User updated successfully!', 'success');
                } else {
                    docRef = await db.collection('users').add(formData);
                    console.log('✅ User added successfully with ID:', docRef.id);
                    showNotification('User added successfully!', 'success');
                }
                
                hideUserForm();
                await loadUsers();
                await refreshStats(); // Update dashboard stats
            } catch (error) {
                console.error('❌ Error saving user:', error);
                showNotification('Error saving user: ' + error.message, 'error');
            }
        }

        function filterUsers() {
            const searchTerm = document.getElementById('usersSearch').value.toLowerCase();
            const userCards = document.querySelectorAll('#usersList .user-card');
            
            userCards.forEach(card => {
                const text = card.textContent.toLowerCase();
                card.style.display = text.includes(searchTerm) ? 'block' : 'none';
            });
        }

        // 4. TAG FORM FUNCTIONS
        function showTagForm(tagId = null) {
            const form = document.getElementById('tagForm');
            const formTitle = document.getElementById('tagFormTitle');
            const formElement = document.getElementById('tagFormElement');
            
            form.style.display = 'block';
            formElement.reset();
            
            if (tagId) {
                formTitle.textContent = 'Edit Tag';
                document.getElementById('tagId').value = tagId;
                loadTagForEdit(tagId);
            } else {
                formTitle.textContent = 'Add New Tag';
                document.getElementById('tagId').value = '';
            }
        }

        function hideTagForm() {
            document.getElementById('tagForm').style.display = 'none';
        }

        async function submitTagForm(event) {
            event.preventDefault();
            
            const tagId = document.getElementById('tagId').value;
            const formData = {
                name: document.getElementById('tagName').value,
                type: document.getElementById('tagCategory').value,
                description: document.getElementById('tagDescription').value,
                color: document.getElementById('tagColor').value,
                isActive: document.getElementById('tagStatus').value === 'active',
                gameCount: 0,
                createdBy: null,
                updatedAt: new Date().toISOString()
            };

            if (!tagId) {
                formData.createdAt = new Date().toISOString();
            }

            try {
                let docRef;
                if (tagId) {
                    await db.collection('tags').doc(tagId).update(formData);
                    console.log('✅ Tag updated successfully');
                    showNotification('Tag updated successfully!', 'success');
                } else {
                    docRef = await db.collection('tags').add(formData);
                    console.log('✅ Tag added successfully with ID:', docRef.id);
                    showNotification('Tag added successfully!', 'success');
                }
                
                hideTagForm();
                await loadTags();
                await refreshStats(); // Update dashboard stats
            } catch (error) {
                console.error('❌ Error saving tag:', error);
                showNotification('Error saving tag: ' + error.message, 'error');
            }
        }

        // 5. MODERATION FORM FUNCTIONS
        function showModerationForm(modId = null) {
            const form = document.getElementById('moderationForm');
            const formTitle = document.getElementById('moderationFormTitle');
            const formElement = document.getElementById('moderationFormElement');
            
            form.style.display = 'block';
            formElement.reset();
            
            if (modId) {
                formTitle.textContent = 'Edit Moderation Log';
                document.getElementById('moderationId').value = modId;
                loadModerationForEdit(modId);
            } else {
                formTitle.textContent = 'Add Moderation Log';
                document.getElementById('moderationId').value = '';
            }
        }

        function hideModerationForm() {
            document.getElementById('moderationForm').style.display = 'none';
        }

        async function submitModerationForm(event) {
            event.preventDefault();
            
            const modId = document.getElementById('moderationId').value;
            const formData = {
                action: document.getElementById('moderationAction').value,
                targetId: document.getElementById('moderationTargetId').value,
                targetType: document.getElementById('moderationTargetType').value,
                moderatorId: document.getElementById('moderationModeratorId').value,
                reason: document.getElementById('moderationReason').value,
                details: document.getElementById('moderationDetails').value,
                severity: document.getElementById('moderationSeverity').value,
                status: document.getElementById('moderationStatus').value,
                timestamp: new Date().toISOString(),
                flagged: true,
                analyzed: true,
                updatedAt: new Date().toISOString()
            };

            if (!modId) {
                formData.createdAt = new Date().toISOString();
            }

            try {
                let docRef;
                if (modId) {
                    await db.collection('moderationLogs').doc(modId).update(formData);
                    console.log('✅ Moderation log updated successfully');
                    showNotification('Moderation log updated successfully!', 'success');
                } else {
                    docRef = await db.collection('moderationLogs').add(formData);
                    console.log('✅ Moderation log added successfully with ID:', docRef.id);
                    showNotification('Moderation log added successfully!', 'success');
                }
                
                hideModerationForm();
                await loadModerationLogs();
                await refreshStats(); // Update dashboard stats
            } catch (error) {
                console.error('❌ Error saving moderation log:', error);
                showNotification('Error saving moderation log: ' + error.message, 'error');
            }
        }

        // 6. USER FORM FUNCTIONS
        function showUserForm(userId = null) {
            const form = document.getElementById('userForm');
            const formTitle = document.getElementById('userFormTitle');
            const formElement = document.getElementById('userFormElement');
            
            form.style.display = 'block';
            formElement.reset();
            
            if (userId) {
                formTitle.textContent = 'Edit User';
                document.getElementById('userId').value = userId;
                loadUserForEdit(userId);
            } else {
                formTitle.textContent = 'Add New User';
                document.getElementById('userId').value = '';
            }
        }

        function hideUserForm() {
            document.getElementById('userForm').style.display = 'none';
        }

        async function submitUserForm(event) {
            event.preventDefault();
            
            const userId = document.getElementById('userId').value;
            const formData = {
                username: document.getElementById('userUsername').value,
                email: document.getElementById('userEmail').value,
                displayName: document.getElementById('userDisplayName').value,
                role: document.getElementById('userRole').value,
                bio: document.getElementById('userBio').value,
                location: document.getElementById('userLocation').value,
                isActive: document.getElementById('userStatus').value === 'active',
                status: document.getElementById('userStatus').value,
                updatedAt: new Date().toISOString()
            };

            if (!userId) {
                formData.createdAt = new Date().toISOString();
            }

            try {
                let docRef;
                if (userId) {
                    await db.collection('users').doc(userId).update(formData);
                    console.log('✅ User updated successfully');
                    showNotification('User updated successfully!', 'success');
                } else {
                    docRef = await db.collection('users').add(formData);
                    console.log('✅ User added successfully with ID:', docRef.id);
                    showNotification('User added successfully!', 'success');
                }
                
                hideUserForm();
                await loadUsers();
                await refreshStats(); // Update dashboard stats
            } catch (error) {
                console.error('❌ Error saving user:', error);
                showNotification('Error saving user: ' + error.message, 'error');
            }
        }

        // FILTER FUNCTIONS
        function filterReviews() {
            const searchTerm = document.getElementById('reviewsSearch').value.toLowerCase();
            const reviewCards = document.querySelectorAll('.review-card');
            
            reviewCards.forEach(card => {
                const title = card.querySelector('h4').textContent.toLowerCase();
                card.style.display = title.includes(searchTerm) ? 'block' : 'none';
            });
        }

        function filterRecommendations() {
            const searchTerm = document.getElementById('recommendationsSearch').value.toLowerCase();
            const recCards = document.querySelectorAll('.recommendation-card');
            
            recCards.forEach(card => {
                const title = card.querySelector('h4').textContent.toLowerCase();
                card.style.display = title.includes(searchTerm) ? 'block' : 'none';
            });
        }

        function filterTags() {
            const searchTerm = document.getElementById('tagsSearch').value.toLowerCase();
            const tagCards = document.querySelectorAll('.tag-card');
            
            tagCards.forEach(card => {
                const title = card.querySelector('h4').textContent.toLowerCase();
                card.style.display = title.includes(searchTerm) ? 'block' : 'none';
            });
        }

        function filterModerationLogs() {
            const searchTerm = document.getElementById('moderationSearch').value.toLowerCase();
            const logCards = document.querySelectorAll('.log-card');
            
            logCards.forEach(card => {
                const title = card.querySelector('h4').textContent.toLowerCase();
                card.style.display = title.includes(searchTerm) ? 'block' : 'none';
            });
        }

        function filterUsers() {
            const searchTerm = document.getElementById('usersSearch').value.toLowerCase();
            const userCards = document.querySelectorAll('.user-card');
            
            userCards.forEach(card => {
                const title = card.querySelector('h3').textContent.toLowerCase();
                card.style.display = title.includes(searchTerm) ? 'block' : 'none';
            });
        }

        // LOAD FOR EDIT FUNCTIONS
        async function loadGameForEdit(gameId) {
            try {
                const doc = await db.collection('games').doc(gameId).get();
                if (doc.exists) {
                    const game = doc.data();
                    document.getElementById('gameTitle').value = game.title || '';
                    document.getElementById('gameDeveloper').value = game.developer || '';
                    document.getElementById('gameGenre').value = Array.isArray(game.genre) ? game.genre.join(', ') : game.genre || '';
                    document.getElementById('gamePlatform').value = Array.isArray(game.platform) ? game.platform.join(', ') : game.platform || '';
                    document.getElementById('gameDescription').value = game.description || '';
                    document.getElementById('gameStatus').value = game.status || 'available';
                    document.getElementById('gameReleaseDate').value = game.releaseDate || '';
                }
            } catch (error) {
                console.error('Error loading game for edit:', error);
            }
        }

        async function loadReviewForEdit(reviewId) {
            try {
                const doc = await db.collection('reviews').doc(reviewId).get();
                if (doc.exists) {
                    const review = doc.data();
                    document.getElementById('reviewGameId').value = review.gameId || '';
                    document.getElementById('reviewUserId').value = review.userId || '';
                    document.getElementById('reviewRating').value = review.rating || '';
                    document.getElementById('reviewTitle').value = review.title || '';
                    document.getElementById('reviewText').value = review.content || '';
                    document.getElementById('reviewRecommended').value = review.recommended ? 'true' : 'false';
                }
            } catch (error) {
                console.error('Error loading review for edit:', error);
            }
        }

        async function loadRecommendationForEdit(recId) {
            try {
                const doc = await db.collection('recommendations').doc(recId).get();
                if (doc.exists) {
                    const rec = doc.data();
                    document.getElementById('recommendationUserId').value = rec.userId || '';
                    document.getElementById('recommendationGameId').value = rec.gameId || '';
                    document.getElementById('recommendationReason').value = rec.reason || '';
                    document.getElementById('recommendationScore').value = rec.score || '';
                    document.getElementById('recommendationDescription').value = rec.description || '';
                    document.getElementById('recommendationCategory').value = rec.category || 'similar_games';
                    document.getElementById('recommendationStatus').value = rec.status || 'active';
                }
            } catch (error) {
                console.error('Error loading recommendation for edit:', error);
            }
        }

        async function loadTagForEdit(tagId) {
            try {
                const doc = await db.collection('tags').doc(tagId).get();
                if (doc.exists) {
                    const tag = doc.data();
                    document.getElementById('tagName').value = tag.name || '';
                    document.getElementById('tagCategory').value = tag.type || '';
                    document.getElementById('tagDescription').value = tag.description || '';
                    document.getElementById('tagColor').value = tag.color || '#007bff';
                    document.getElementById('tagStatus').value = tag.isActive ? 'active' : 'inactive';
                }
            } catch (error) {
                console.error('Error loading tag for edit:', error);
            }
        }

        async function loadModerationForEdit(modId) {
            try {
                const doc = await db.collection('moderationLogs').doc(modId).get();
                if (doc.exists) {
                    const mod = doc.data();
                    document.getElementById('moderationAction').value = mod.action || '';
                    document.getElementById('moderationTargetId').value = mod.targetId || '';
                    document.getElementById('moderationTargetType').value = mod.targetType || '';
                    document.getElementById('moderationModeratorId').value = mod.moderatorId || '';
                    document.getElementById('moderationReason').value = mod.reason || '';
                    document.getElementById('moderationDetails').value = mod.details || '';
                    document.getElementById('moderationSeverity').value = mod.severity || 'medium';
                    document.getElementById('moderationStatus').value = mod.status || 'active';
                }
            } catch (error) {
                console.error('Error loading moderation log for edit:', error);
            }
        }

        async function loadUserForEdit(userId) {
            try {
                const doc = await db.collection('users').doc(userId).get();
                if (doc.exists) {
                    const user = doc.data();
                    document.getElementById('userUsername').value = user.username || '';
                    document.getElementById('userEmail').value = user.email || '';
                    document.getElementById('userDisplayName').value = user.displayName || '';
                    document.getElementById('userRole').value = user.role || 'user';
                    document.getElementById('userBio').value = user.bio || '';
                    document.getElementById('userLocation').value = user.location || '';
                    document.getElementById('userStatus').value = user.status || 'active';
                }
            } catch (error) {
                console.error('Error loading user for edit:', error);
            }
        }

        // NOTIFICATION SYSTEM
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div class="notification-content">
                    <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                    <span>${message}</span>
                </div>
                <button class="notification-close" onclick="this.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }

        // GESTURE GENERATOR LAUNCHER
        function launchGestureGenerator() {
            try {
                showNotification('Launching Gesture Generator...', 'info');
                
                // For Windows, we'll use a command to run the batch file
                // Since we can't directly execute system commands from browser,
                // we'll provide instructions to the user
                const instructions = `
                    <div style="text-align: left; max-width: 500px;">
                        <h3>🎮 Launch Gesture Generator</h3>
                        <p><strong>Step 1:</strong> Open File Explorer</p>
                        <p><strong>Step 2:</strong> Navigate to your project folder:</p>
                        <code>C:\\Users\\23038791\\OneDrive - Republic Polytechnic\\Downloads\\fyp</code>
                        <p><strong>Step 3:</strong> Double-click: <strong>run_gesture_generator.bat</strong></p>
                        <br>
                        <p><i class="fas fa-info-circle"></i> The gesture generator will open with webcam access and AI-powered game idea generation!</p>
                    </div>
                `;
                
                // Create a modal-like dialog
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.8); z-index: 10000; display: flex;
                    align-items: center; justify-content: center;
                `;
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white; padding: 30px; border-radius: 10px;
                    max-width: 600px; max-height: 80vh; overflow-y: auto;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                
                dialog.innerHTML = instructions + `
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="this.closest('[style*=fixed]').remove()" 
                                style="background: #007bff; color: white; border: none; 
                                       padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            Got it! <i class="fas fa-check"></i>
                        </button>
                    </div>
                `;
                
                modal.appendChild(dialog);
                document.body.appendChild(modal);
                
                // Also try to open file explorer programmatically (may not work in all browsers)
                try {
                    window.open('file:///C:/Users/23038791/OneDrive%20-%20Republic%20Polytechnic/Downloads/fyp/', '_blank');
                } catch (e) {
                    console.log('Could not open file explorer automatically');
                }
                
            } catch (error) {
                console.error('Error launching gesture generator:', error);
                showNotification('Error launching gesture generator. Please run run_gesture_generator.bat manually.', 'error');
            }
        }

        // Event Listeners
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const page = link.dataset.page;
                showPage(page);
            });
        });

        // Initialize on page load
        window.addEventListener('load', async () => {
            const success = await initFirebase();
            if (success) {
                await refreshStats();
                console.log('🎉 Gamevibe Arena initialized successfully!');
                
                // Add form submission listeners after DOM is loaded
                const gameForm = document.getElementById('gameFormElement');
                if (gameForm) {
                    gameForm.addEventListener('submit', function(e) {
                        e.preventDefault();
                        console.log('🎯 Form submission event triggered via event listener!');
                        submitGameForm(e);
                    });
                }
                
                // Add gesture generator launch functionality
                const gestureBtn = document.getElementById('launch-gesture-generator');
                if (gestureBtn) {
                    gestureBtn.addEventListener('click', function() {
                        launchGestureGenerator();
                    });
                }
                
                // Add eye tracker launch functionality
                const eyeTrackerBtn = document.getElementById('launch-eye-tracker');
                if (eyeTrackerBtn) {
                    eyeTrackerBtn.addEventListener('click', function() {
                        launchEyeTracker();
                    });
                }
                
                // Auto-refresh data every  30 seconds to ensure mutual sync
                setInterval(async () => {
                    const currentPage = document.querySelector('.page.active').id;
                    if (currentPage !== 'dashboard') {
                        await loadPageData(currentPage);
                    }
                    await refreshStats();
                }, 30000); // 30 seconds
            } else {
                console.error('❌ Failed to initialize Gamevibe Arena');
            }
        });

        // Add visibility change listener for real-time sync
        document.addEventListener('visibilitychange', async () => {
            if (!document.hidden) {
                // Page became visible, refresh current data
                const currentPage = document.querySelector('.page.active').id;
                await loadPageData(currentPage);
                await refreshStats();
                console.log('🔄 Data refreshed due to page visibility change');
            }
        });

        // ================================
        // MOODBOARD GENERATION FUNCTIONALITY
        // ================================

        // Global variable to store current generated game
        window.currentGeneratedGame = null;

        // Use CheapShark moodboard generation instead
        function generateMoodboard() {
            // Redirect to CheapShark-based generation
            showNotification('Please use the CheapShark Game Mixer section below to create moodboards!', 'info');
            
            // Scroll to CheapShark section
            const cheapSharkSection = document.querySelector('.generate-container');
            if (cheapSharkSection) {
                cheapSharkSection.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Generate description using Google Gemini 2.5 Pro
        async function generateMoodboardDescription(gameType, gameTheme, artStyle, targetPlatform, additionalPrompts) {
            const prompt = `Create a detailed game concept description for a ${gameType} game with ${gameTheme} theme, ${artStyle} art style, targeting ${targetPlatform} platform. ${additionalPrompts ? 'Additional requirements: ' + additionalPrompts : ''} 

            Please provide:
            1. Game Title
            2. Core Gameplay Mechanics
            3. Visual Style & Atmosphere
            4. Key Features
            5. Target Audience

            Keep it concise but engaging, around 200-250 words.`;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyDs85pi4hcRqtFUg-mrNgci9aWPV1pUI_M`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: prompt
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.8,
                            maxOutputTokens: 250,
                        },
                        safetySettings: [
                            {
                                category: "HARM_CATEGORY_HARASSMENT",
                                threshold: "BLOCK_MEDIUM_AND_ABOVE"
                            },
                            {
                                category: "HARM_CATEGORY_HATE_SPEECH", 
                                threshold: "BLOCK_MEDIUM_AND_ABOVE"
                            }
                        ]
                    })
                });

                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status}`);
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
                
            } catch (error) {
                console.error('Error with Gemini API:', error);
                // Fallback description
                return `${gameType.charAt(0).toUpperCase() + gameType.slice(1)} Game Concept

                **Theme:** ${gameTheme.charAt(0).toUpperCase() + gameTheme.slice(1)}
                **Art Style:** ${artStyle.charAt(0).toUpperCase() + artStyle.slice(1)}
                **Platform:** ${targetPlatform.charAt(0).toUpperCase() + targetPlatform.slice(1)}

                An innovative ${gameType} game featuring ${gameTheme} elements with a distinctive ${artStyle} visual approach. Designed specifically for ${targetPlatform}, this game combines engaging mechanics with immersive storytelling.

                ${additionalPrompts ? `Special Features: ${additionalPrompts}` : ''}

                This concept offers unique gameplay opportunities and visual appeal that will captivate players and create memorable gaming experiences.`;
            }
        }

        // Generate images for moodboard
        async function generateMoodboardImages(gameType, gameTheme, artStyle, description) {
            const images = [];
            const imagePrompts = [
                `${gameType} game environment, ${gameTheme} theme, ${artStyle} art style`,
                `${gameType} game character design, ${gameTheme} aesthetic, ${artStyle} style`,
                `${gameType} game interface and UI, ${gameTheme} theme, ${artStyle} design`,
                `${gameType} game atmosphere and mood, ${gameTheme} world, ${artStyle} rendering`
            ];

            const imageServices = [
                {
                    name: 'Pollinations AI',
                    generateUrl: (prompt) => `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?width=400&height=300&seed=${Date.now()}`
                },
                {
                    name: 'Hugging Face',
                    generateUrl: (prompt) => `https://api-inference.huggingface.co/models/black-forest-labs/FLUX.1-dev`
                },
                {
                    name: 'DeepAI',
                    generateUrl: (prompt) => 'https://api.deepai.org/api/text2img'
                }
            ];

            for (let i = 0; i < imagePrompts.length; i++) {
                try {
                    // Try Pollinations AI first (most reliable)
                    const imageUrl = imageServices[0].generateUrl(imagePrompts[i]);
                    
                    // Test if image loads
                    await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = resolve;
                        img.onerror = reject;
                        img.src = imageUrl;
                    });
                    
                    images.push({
                        url: imageUrl,
                        prompt: imagePrompts[i],
                        service: 'Pollinations AI'
                    });
                    
                } catch (error) {
                    console.warn(`Failed to generate image ${i + 1}:`, error);
                    // Fallback to procedural generation
                    images.push({
                        url: generateProceduralImage(gameType, gameTheme, artStyle),
                        prompt: imagePrompts[i],
                        service: 'Procedural Fallback'
                    });
                }
            }

            return images;
        }

        // Procedural image generation fallback
        function generateProceduralImage(gameType, gameTheme, artStyle) {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');

            // Color schemes based on theme
            const colorSchemes = {
                'sci-fi': ['#0066cc', '#00ccff', '#333366', '#66ccff'],
                'fantasy': ['#006600', '#669933', '#cc9900', '#663300'],
                'medieval': ['#663300', '#996633', '#cc9966', '#333300'],
                'modern': ['#666666', '#999999', '#cccccc', '#333333'],
                'cyberpunk': ['#ff0066', '#00ffcc', '#cc00ff', '#000033'],
                'steampunk': ['#cc6600', '#996633', '#ffcc66', '#333300'],
                'post-apocalyptic': ['#663300', '#996600', '#cc9900', '#333333'],
                'historical': ['#996633', '#cc9966', '#ffcc99', '#663300'],
                'space': ['#000033', '#003366', '#0066cc', '#ffffff'],
                'underwater': ['#003366', '#0066cc', '#00ccff', '#66ccff']
            };

            const colors = colorSchemes[gameTheme] || ['#666666', '#999999', '#cccccc', '#333333'];

            // Create gradient background
            const gradient = ctx.createLinearGradient(0, 0, 400, 300);
            gradient.addColorStop(0, colors[0]);
            gradient.addColorStop(0.5, colors[1]);
            gradient.addColorStop(1, colors[2]);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 400, 300);

            // Add decorative elements based on game type
            ctx.fillStyle = colors[3];
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 400;
                const y = Math.random() * 300;
                const size = Math.random() * 20 + 5;
                
                if (gameType === 'puzzle') {
                    ctx.fillRect(x, y, size, size);
                } else if (gameType === 'action') {
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    ctx.fillRect(x, y, size, size/2);
                }
            }

            // Add text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(gameType.toUpperCase(), 200, 150);
            
            ctx.font = '16px Arial';
            ctx.fillText(gameTheme + ' | ' + artStyle, 200, 180);

            return canvas.toDataURL();
        }

        // Display the generated moodboard
        function displayMoodboard(description, images) {
            const moodboardResult = document.getElementById('moodboardResult');
            
            const html = `
                <div class="moodboard-container">
                    <div class="moodboard-description">
                        <h4>Game Concept</h4>
                        <div class="description-content">${description.replace(/\n/g, '<br>')}</div>
                    </div>
                    
                    <div class="moodboard-images">
                        <h4>Visual Inspiration</h4>
                        <div class="images-grid">
                            ${images.map((img, index) => `
                                <div class="moodboard-image">
                                    <img src="${img.url}" alt="${img.prompt}" loading="lazy">
                                    <div class="image-caption">${img.prompt}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="moodboard-actions">
                        <button class="btn btn-success" onclick="saveMoodboard()">
                            <i class="fas fa-save"></i> Save Game Idea
                        </button>
                    </div>
                </div>
            `;
            
            moodboardResult.innerHTML = html;
        }

        // Regenerate moodboard
        async function regenerateMoodboard() {
            if (!window.currentGeneratedGame) {
                alert('No current game to regenerate. Please generate a new moodboard first.');
                return;
            }
            
            const game = window.currentGeneratedGame;
            
            // Update form values
            document.getElementById('gameType').value = game.gameType;
            document.getElementById('gameTheme').value = game.gameTheme;
            document.getElementById('artStyle').value = game.artStyle;
            document.getElementById('targetPlatform').value = game.targetPlatform;
            document.getElementById('additionalPrompts').value = game.additionalPrompts || '';
            
            // Generate new moodboard
            await generateMoodboard();
        }

        // Save moodboard to Firebase
        async function saveMoodboard() {
            if (!window.currentGeneratedGame) {
                alert('No game concept to save. Please generate a moodboard first.');
                return;
            }
            
            try {
                // Add voting fields to the game data
                const gameDataWithVoting = {
                    ...window.currentGeneratedGame,
                    votes: 0,
                    voters: [],
                    rating: 0,
                    ratingCount: 0,
                    raters: [], // Added raters array for tracking who rated
                    createdAt: new Date().toISOString(),
                    isPublic: true
                };
                
                const docRef = await db.collection('gameIdeas').add(gameDataWithVoting);
                console.log('✅ Game idea saved with ID:', docRef.id);
                showNotification('Game idea saved successfully and added to leaderboard!', 'success');
                
                // Refresh the list
                await loadGameIdeas();
                
            } catch (error) {
                console.error('❌ Error saving game idea:', error);
                showNotification('Error saving game idea: ' + error.message, 'error');
            }
        }

        // Load game ideas from Firebase
        // ================================
        // CHEAPSHARK GAME MIXER FUNCTIONALITY
        // ================================

        // Store CheapShark games data
        let cheapSharkGames = [];
        let selectedGames = [];

        // Load games from CheapShark API
        async function loadCheapSharkGames() {
            try {
                showNotification('Loading games from CheapShark...', 'info');
                console.log('🎮 Fetching games from CheapShark API...');
                
                const response = await fetch('https://www.cheapshark.com/api/1.0/deals?pageSize=100&sortBy=recent');
                const deals = await response.json();
                
                // Transform deals into game objects
                cheapSharkGames = deals.map((deal, index) => ({
                    id: deal.gameID || index,
                    title: deal.title,
                    steamRating: deal.steamRatingPercent || 'N/A',
                    steamReviews: deal.steamRatingText || 'No reviews',
                    originalPrice: deal.normalPrice,
                    salePrice: deal.salePrice,
                    savings: deal.savings,
                    thumb: deal.thumb,
                    storeID: deal.storeID,
                    dealID: deal.dealID,
                    // Infer genre and mechanics from title (simplified approach)
                    inferredGenre: inferGameGenre(deal.title),
                    inferredMechanics: inferGameMechanics(deal.title)
                }));

                console.log(`✅ Loaded ${cheapSharkGames.length} games from CheapShark`);
                showNotification(`Loaded ${cheapSharkGames.length} games! Now select games to mix.`, 'success');
                
                updateGameSelectors();
                
            } catch (error) {
                console.error('❌ Error loading CheapShark games:', error);
                showNotification('Loading games...', 'info');
            }
        }

        // Infer game genre from title (basic keyword matching)
        function inferGameGenre(title) {
            const titleLower = title.toLowerCase();
            
            if (titleLower.includes('war') || titleLower.includes('battle') || titleLower.includes('combat') || titleLower.includes('shooter')) return 'Action';
            if (titleLower.includes('puzzle') || titleLower.includes('tetris') || titleLower.includes('match')) return 'Puzzle';
            if (titleLower.includes('rpg') || titleLower.includes('fantasy') || titleLower.includes('quest') || titleLower.includes('legend')) return 'RPG';
            if (titleLower.includes('strategy') || titleLower.includes('civilization') || titleLower.includes('empire')) return 'Strategy';
            if (titleLower.includes('racing') || titleLower.includes('car') || titleLower.includes('driver')) return 'Racing';
            if (titleLower.includes('horror') || titleLower.includes('zombie') || titleLower.includes('dead') || titleLower.includes('evil')) return 'Horror';
            if (titleLower.includes('sport') || titleLower.includes('football') || titleLower.includes('soccer') || titleLower.includes('basketball')) return 'Sports';
            if (titleLower.includes('sim') || titleLower.includes('tycoon') || titleLower.includes('city') || titleLower.includes('farm')) return 'Simulation';
            if (titleLower.includes('adventure') || titleLower.includes('explore') || titleLower.includes('journey')) return 'Adventure';
            
            return 'Indie'; // Default fallback
        }

        // Infer game mechanics from title
        function inferGameMechanics(title) {
            const titleLower = title.toLowerCase();
            const mechanics = [];
            
            if (titleLower.includes('multiplayer') || titleLower.includes('online')) mechanics.push('Multiplayer');
            if (titleLower.includes('open world') || titleLower.includes('sandbox')) mechanics.push('Open World');
            if (titleLower.includes('building') || titleLower.includes('craft')) mechanics.push('Building/Crafting');
            if (titleLower.includes('turn') || titleLower.includes('tactical')) mechanics.push('Turn-based');
            if (titleLower.includes('real time') || titleLower.includes('rts')) mechanics.push('Real-time');
            if (titleLower.includes('platform') || titleLower.includes('jump')) mechanics.push('Platforming');
            if (titleLower.includes('stealth') || titleLower.includes('sneak')) mechanics.push('Stealth');
            if (titleLower.includes('co-op') || titleLower.includes('coop')) mechanics.push('Cooperative');
            
            return mechanics.length > 0 ? mechanics : ['Single-player', 'Story-driven'];
        }

        // Update game selector dropdowns
        function updateGameSelectors() {
            const gameCount = parseInt(document.getElementById('gameCount').value);
            const container = document.getElementById('gameSelectors');
            
            let html = '';
            for (let i = 0; i < gameCount; i++) {
                html += `
                    <div class="game-selector">
                        <label for="game${i + 1}">Game ${i + 1}</label>
                        <select id="game${i + 1}" onchange="updateSelectedGames()">
                            <option value="">Choose a game...</option>
                            ${cheapSharkGames.map(game => `
                                <option value="${game.id}" data-game='${JSON.stringify(game)}'>
                                    ${game.title} (${game.inferredGenre})
                                </option>
                            `).join('')}
                        </select>
                    </div>
                `;
            }
            
            container.innerHTML = html;
            selectedGames = [];
            document.getElementById('selectedGamesPreview').style.display = 'none';
            document.getElementById('generationControls').style.display = 'none';
        }

        // Randomly select games for mixing
        function randomlySelectGames() {
            if (cheapSharkGames.length === 0) {
                showNotification('Please load CheapShark games first!', 'warning');
                return;
            }

            const gameCount = parseInt(document.getElementById('gameCount').value);
            const randomGames = [];
            
            // Get random unique games
            while (randomGames.length < gameCount && randomGames.length < cheapSharkGames.length) {
                const randomIndex = Math.floor(Math.random() * cheapSharkGames.length);
                const randomGame = cheapSharkGames[randomIndex];
                
                if (!randomGames.find(g => g.id === randomGame.id)) {
                    randomGames.push(randomGame);
                }
            }

            // Populate selectors with random games
            randomGames.forEach((game, index) => {
                const selector = document.getElementById(`game${index + 1}`);
                if (selector) {
                    selector.value = game.id;
                }
            });

            updateSelectedGames();
            showNotification(`Randomly selected ${randomGames.length} games for mixing!`, 'success');
        }

        // Update selected games preview
        function updateSelectedGames() {
            selectedGames = [];
            const gameCount = parseInt(document.getElementById('gameCount').value);
            
            for (let i = 0; i < gameCount; i++) {
                const selector = document.getElementById(`game${i + 1}`);
                if (selector && selector.value) {
                    const selectedOption = selector.selectedOptions[0];
                    if (selectedOption && selectedOption.dataset.game) {
                        selectedGames.push(JSON.parse(selectedOption.dataset.game));
                    }
                }
            }

            if (selectedGames.length > 1) {
                displaySelectedGamesPreview();
                document.getElementById('generationControls').style.display = 'block';
            } else {
                document.getElementById('selectedGamesPreview').style.display = 'none';
                document.getElementById('generationControls').style.display = 'none';
            }
        }

        // Display selected games preview
        function displaySelectedGamesPreview() {
            const container = document.getElementById('gamePreviewCards');
            
            const html = selectedGames.map((game, index) => `
                <div class="game-preview-card">
                    <div class="preview-image">
                        <img src="${game.thumb}" alt="${game.title}" onerror="this.src='https://via.placeholder.com/150x70?text=Game+${index + 1}'">
                    </div>
                    <div class="preview-info">
                        <h5>${game.title}</h5>
                        <p class="game-genre">${game.inferredGenre}</p>
                        <p class="game-mechanics">${game.inferredMechanics.join(', ')}</p>
                        <p class="game-rating">
                            <i class="fas fa-star"></i> ${game.steamRating}% 
                            <small>(${game.steamReviews})</small>
                        </p>
                    </div>
                </div>
            `).join('');

            container.innerHTML = html;
            document.getElementById('selectedGamesPreview').style.display = 'block';
        }

        // Generate visual moodboard from selected games
        async function generateMoodboard() {
            if (selectedGames.length < 2) {
                showNotification('Please select at least 2 games to create a moodboard!', 'warning');
                return;
            }

            try {
                showNotification('Creating visual moodboard...', 'info');
                
                // Create game concept data
                const gameTitle = `${selectedGames[0].title.split(' ')[0]} ${selectedGames[1].title.split(' ')[0]} Mix`;
                const gameType = selectedGames[0].inferredGenre.toLowerCase();
                const gameTheme = inferThemeFromGames(selectedGames);
                const artStyle = inferArtStyleFromGames(selectedGames);
                const targetPlatform = document.getElementById('targetPlatform').value;
                const additionalPrompts = document.getElementById('additionalPrompts').value;

                // Store the generated game data
                window.currentGeneratedGame = {
                    gameType: gameType,
                    gameTheme: gameTheme,
                    artStyle: artStyle,
                    targetPlatform: targetPlatform,
                    additionalPrompts: additionalPrompts,
                    sourceGames: selectedGames.map(g => g.title),
                    mixingStyle: document.getElementById('mixingStyle').value,
                    creativityLevel: document.getElementById('creativityLevel').value,
                    createdAt: new Date().toISOString(),
                    title: gameTitle
                };

                // Generate description based on mixed games
                const description = generateGameDescription(selectedGames, gameTitle);
                
                // Generate images for moodboard
                const images = await generateMoodboardImages(gameType, gameTheme, artStyle, selectedGames);
                
                window.currentGeneratedGame.description = description;
                window.currentGeneratedGame.images = images;

                displayMoodboard(description, images);
                
                // Show the generated content section
                document.getElementById('generatedContent').style.display = 'block';
                
                showNotification('Moodboard created successfully!', 'success');

            } catch (error) {
                console.error('❌ Error generating moodboard:', error);
                showNotification('Error generating moodboard: ' + error.message, 'error');
            }
        }

        // Infer theme from selected games
        function inferThemeFromGames(games) {
            const themes = games.map(game => {
                const title = game.title.toLowerCase();
                if (title.includes('war') || title.includes('battle')) return 'post-apocalyptic';
                if (title.includes('fantasy') || title.includes('magic') || title.includes('legend')) return 'fantasy';
                if (title.includes('space') || title.includes('star') || title.includes('galaxy')) return 'space';
                if (title.includes('cyber') || title.includes('tech') || title.includes('digital')) return 'cyberpunk';
                if (title.includes('medieval') || title.includes('knight') || title.includes('castle')) return 'medieval';
                return 'modern';
            });
            
            // Return most common theme or default
            return themes[0] || 'modern';
        }

        // Infer art style from selected games
        function inferArtStyleFromGames(games) {
            const styles = games.map(game => {
                const title = game.title.toLowerCase();
                if (title.includes('pixel') || title.includes('retro') || title.includes('8-bit')) return 'pixel';
                if (title.includes('cartoon') || title.includes('cute') || title.includes('fun')) return 'cartoon';
                if (title.includes('anime') || title.includes('manga')) return 'anime';
                if (title.includes('realistic') || title.includes('simulation')) return 'realistic';
                return 'cartoon';
            });
            
            return styles[0] || 'cartoon';
        }

        // Generate game description
        function generateGameDescription(games, title) {
            const genres = [...new Set(games.map(g => g.inferredGenre))];
            const mechanics = games.flatMap(g => g.inferredMechanics);
            
            return `${title} combines the best elements of ${games.map(g => g.title).join(', ')}. 
            This innovative ${genres.join('/')} game features ${mechanics.slice(0, 3).join(', ')} mechanics, 
            creating a unique gaming experience that appeals to fans of all source games. 
            The game blends familiar gameplay elements in unexpected ways, offering both 
            nostalgic appeal and fresh innovation.`;
        }

        // Generate moodboard images
        async function generateMoodboardImages(gameType, gameTheme, artStyle, sourceGames) {
            const images = [];
            
            // Generate prompts based on mixed games
            const imagePrompts = [
                `${gameType} game character in ${artStyle} style with ${gameTheme} theme`,
                `${gameType} game environment ${gameTheme} setting ${artStyle} art style`,
                `${gameType} game UI interface design ${artStyle} style`,
                `${gameType} game weapon or item ${gameTheme} theme ${artStyle} style`
            ];

            for (let i = 0; i < imagePrompts.length; i++) {
                try {
                    const imageUrl = await generateImageWithFallback(imagePrompts[i]);
                    images.push({
                        url: imageUrl,
                        type: ['Character', 'Environment', 'UI Design', 'Items'][i],
                        prompt: imagePrompts[i]
                    });
                } catch (error) {
                    console.warn(`Failed to generate image ${i + 1}:`, error);
                    // Add placeholder
                    images.push({
                        url: `https://via.placeholder.com/400x300?text=${['Character', 'Environment', 'UI', 'Items'][i]}`,
                        type: ['Character', 'Environment', 'UI Design', 'Items'][i],
                        prompt: imagePrompts[i]
                    });
                }
            }

            return images;
        }

        // Generate image with multiple API fallbacks
        async function generateImageWithFallback(prompt) {
            const services = [
                {
                    name: 'Pollinations',
                    url: `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?width=400&height=300&seed=${Math.floor(Math.random() * 1000)}`
                },
                {
                    name: 'Placeholder',
                    url: `https://via.placeholder.com/400x300/667eea/ffffff?text=${encodeURIComponent(prompt.substring(0, 20))}`
                }
            ];

            for (const service of services) {
                try {
                    console.log(`🎨 Trying ${service.name} for: ${prompt}`);
                    
                    if (service.name === 'Pollinations') {
                        // Test if image loads
                        const response = await fetch(service.url);
                        if (response.ok) {
                            return service.url;
                        }
                    } else {
                        return service.url;
                    }
                } catch (error) {
                    console.warn(`${service.name} failed:`, error);
                }
            }

            // Final fallback
            return `https://via.placeholder.com/400x300?text=${encodeURIComponent('Game+Concept')}`;
        }

        // Generate price suggestion for the mixed game
        async function generatePriceSuggestion() {
            if (selectedGames.length < 2) {
                showNotification('Please select games first!', 'warning');
                return;
            }

            try {
                showNotification('Calculating suggested price...', 'info');
                
                // Analyze source games for pricing
                const avgPrice = selectedGames.reduce((sum, game) => {
                    const price = parseFloat(game.originalPrice) || 20; // Default $20 if no price
                    return sum + price;
                }, 0) / selectedGames.length;

                const maxPrice = Math.max(...selectedGames.map(g => parseFloat(g.originalPrice) || 20));
                const minPrice = Math.min(...selectedGames.map(g => parseFloat(g.originalPrice) || 5));

                // Calculate complexity score
                const uniqueGenres = [...new Set(selectedGames.map(g => g.inferredGenre))].length;
                const totalMechanics = selectedGames.flatMap(g => g.inferredMechanics).length;
                const complexityMultiplier = 1 + (uniqueGenres * 0.1) + (totalMechanics * 0.05);

                // Platform multipliers
                const platformMultipliers = {
                    'pc': 1.0,
                    'console': 1.2,
                    'mobile': 0.6,
                    'vr': 1.5,
                    'web': 0.8,
                    'multi': 1.3
                };

                const platform = document.getElementById('targetPlatform').value;
                const platformMultiplier = platformMultipliers[platform] || 1.0;

                // Calculate suggested prices
                const basePrice = avgPrice * complexityMultiplier * platformMultiplier;
                const conservativePrice = Math.max(minPrice * 0.8, basePrice * 0.7);
                const moderatePrice = basePrice;
                const premiumPrice = Math.min(maxPrice * 1.5, basePrice * 1.4);

                // Round to reasonable values
                const suggestions = {
                    conservative: Math.round(conservativePrice * 2) / 2, // Round to nearest $0.50
                    moderate: Math.round(moderatePrice * 2) / 2,
                    premium: Math.round(premiumPrice * 2) / 2,
                    sourceAnalysis: {
                        avgSourcePrice: Math.round(avgPrice * 100) / 100,
                        priceRange: `$${minPrice.toFixed(2)} - $${maxPrice.toFixed(2)}`,
                        complexityScore: Math.round(complexityMultiplier * 100) / 100,
                        platformMultiplier: platformMultiplier
                    }
                };

                displayPriceSuggestion(suggestions);
                
                // Add pricing to current game data
                if (window.currentGeneratedGame) {
                    window.currentGeneratedGame.priceSuggestions = suggestions;
                }

                showNotification('Price suggestions calculated!', 'success');

            } catch (error) {
                console.error('❌ Error generating price suggestion:', error);
                showNotification('Error calculating price: ' + error.message, 'error');
            }
        }

        // Display price suggestions
        function displayPriceSuggestion(suggestions) {
            const container = document.getElementById('priceSuggestion');
            
            const html = `
                <div class="price-analysis">
                    <div class="source-analysis">
                        <h4><i class="fas fa-chart-bar"></i> Market Analysis</h4>
                        <div class="analysis-grid">
                            <div class="analysis-item">
                                <span class="label">Average Source Price:</span>
                                <span class="value">$${suggestions.sourceAnalysis.avgSourcePrice}</span>
                            </div>
                            <div class="analysis-item">
                                <span class="label">Source Price Range:</span>
                                <span class="value">${suggestions.sourceAnalysis.priceRange}</span>
                            </div>
                            <div class="analysis-item">
                                <span class="label">Complexity Score:</span>
                                <span class="value">${suggestions.sourceAnalysis.complexityScore}x</span>
                            </div>
                            <div class="analysis-item">
                                <span class="label">Platform Multiplier:</span>
                                <span class="value">${suggestions.sourceAnalysis.platformMultiplier}x</span>
                            </div>
                        </div>
                    </div>

                    <div class="price-suggestions">
                        <h4><i class="fas fa-dollar-sign"></i> Suggested Selling Prices</h4>
                        <div class="price-options">
                            <div class="price-option budget">
                                <div class="price-header">
                                    <h5>Budget Launch</h5>
                                    <span class="price">$${suggestions.conservative}</span>
                                </div>
                                <p>Conservative pricing to attract early adopters and build player base</p>
                                <ul>
                                    <li>Lower barrier to entry</li>
                                    <li>Faster initial sales</li>
                                    <li>Good for indie developers</li>
                                </ul>
                            </div>

                            <div class="price-option standard recommended">
                                <div class="price-header">
                                    <h5>Standard Price <span class="badge">Recommended</span></h5>
                                    <span class="price">$${suggestions.moderate}</span>
                                </div>
                                <p>Balanced pricing based on game complexity and market analysis</p>
                                <ul>
                                    <li>Optimal price-to-value ratio</li>
                                    <li>Competitive with similar games</li>
                                    <li>Sustainable revenue model</li>
                                </ul>
                            </div>

                            <div class="price-option premium">
                                <div class="price-header">
                                    <h5>Premium Launch</h5>
                                    <span class="price">$${suggestions.premium}</span>
                                </div>
                                <p>Premium pricing for high-quality innovative gameplay</p>
                                <ul>
                                    <li>Higher profit margins</li>
                                    <li>Targets enthusiast gamers</li>
                                    <li>Requires strong marketing</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="pricing-tips">
                        <h5><i class="fas fa-lightbulb"></i> Pricing Strategy Tips</h5>
                        <ul>
                            <li>Consider launching at standard price with limited-time discount</li>
                            <li>Monitor competitor pricing and adjust accordingly</li>
                            <li>Plan for seasonal sales and promotions</li>
                            <li>Consider early access pricing strategy</li>
                        </ul>
                    </div>
                </div>
            `;

            container.innerHTML = html;
            document.getElementById('pricingSectionContent').style.display = 'block';
        }

        // Start a new game mix
        function startNewMix() {
            selectedGames = [];
            document.getElementById('gameSelectors').innerHTML = '';
            document.getElementById('selectedGamesPreview').style.display = 'none';
            document.getElementById('generationControls').style.display = 'none';
            document.getElementById('generatedContent').style.display = 'none';
            document.getElementById('gameCount').value = '3';
            window.currentGeneratedGame = null;
            
            if (cheapSharkGames.length > 0) {
                updateGameSelectors();
            }
            
            showNotification('Ready for a new game mix!', 'info');
        }

        // ================================
        // GAME IDEAS CRUD OPERATIONS
        // ================================

        async function loadGameIdeas() {
            try {
                console.log('Loading game ideas...');
                const snapshot = await db.collection('gameIdeas').orderBy('createdAt', 'desc').get();
                const gameIdeas = [];
                
                snapshot.forEach(doc => {
                    gameIdeas.push({ id: doc.id, ...doc.data() });
                });

                const html = gameIdeas.length > 0 
                    ? gameIdeas.map(game => `
                        <div class="game-idea-card">
                            <h4>${game.gameType || 'Unknown Type'} | ${game.gameTheme || 'Unknown Theme'}</h4>
                            <p><strong>Art Style:</strong> ${game.artStyle || 'Not specified'}</p>  
                            <p><strong>Platform:</strong> ${game.targetPlatform || 'Not specified'}</p>
                            <p><strong>Created:</strong> ${new Date(game.createdAt).toLocaleDateString()}</p>
                            ${game.description ? `<p class="game-description"><strong>Description:</strong> ${game.description.substring(0, 100)}${game.description.length > 100 ? '...' : ''}</p>` : ''}
                            <div class="card-actions">
                                <button onclick="editGameIdea('${game.id}')" class="btn btn-sm btn-primary">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                                <button onclick="deleteGameIdea('${game.id}')" class="btn btn-sm btn-danger">
                                    <i class="fas fa-trash"></i> Delete
                                </button>
                            </div>
                        </div>
                    `).join('')
                    : '<p>No game ideas yet. Create your first game concept above!</p>';

                document.getElementById('gameIdeasList').innerHTML = html;
                console.log(`✅ Loaded ${gameIdeas.length} game ideas`);
                
            } catch (error) {
                console.error('❌ Error loading game ideas:', error);
                document.getElementById('gameIdeasList').innerHTML = `<p>Loading game ideas...</p>`;
            }
        }

        // Edit a specific game idea
        async function editGameIdea(gameId) {
            try {
                const gameDoc = await db.collection('gameIdeas').doc(gameId).get();
                if (gameDoc.exists) {
                    const gameData = gameDoc.data();
                    
                    // Populate form fields
                    document.getElementById('editGameIdeaId').value = gameId;
                    document.getElementById('editGameType').value = gameData.gameType || '';
                    document.getElementById('editGameTheme').value = gameData.gameTheme || '';
                    document.getElementById('editArtStyle').value = gameData.artStyle || '';
                    document.getElementById('editTargetPlatform').value = gameData.targetPlatform || '';
                    document.getElementById('editAdditionalPrompts').value = gameData.additionalPrompts || '';
                    document.getElementById('editDescription').value = gameData.description || '';
                    
                    // Show the edit form
                    document.getElementById('editGameIdeaForm').style.display = 'block';
                    document.getElementById('editGameIdeaForm').scrollIntoView({ behavior: 'smooth' });
                }
            } catch (error) {
                console.error('Error loading game idea for editing:', error);
                showNotification('Error loading game idea: ' + error.message, 'error');
            }
        }

        // Hide edit game idea form
        function hideEditGameIdeaForm() {
            document.getElementById('editGameIdeaForm').style.display = 'none';
        }

        // Update game idea
        async function updateGameIdea(event) {
            event.preventDefault();
            
            try {
                const gameId = document.getElementById('editGameIdeaId').value;
                const updateData = {
                    gameType: document.getElementById('editGameType').value,
                    gameTheme: document.getElementById('editGameTheme').value,
                    artStyle: document.getElementById('editArtStyle').value,
                    targetPlatform: document.getElementById('editTargetPlatform').value,
                    additionalPrompts: document.getElementById('editAdditionalPrompts').value,
                    description: document.getElementById('editDescription').value,
                    updatedAt: new Date().toISOString()
                };

                await db.collection('gameIdeas').doc(gameId).update(updateData);
                console.log(`✅ Game idea updated: ${gameId}`);
                showNotification('Game idea updated successfully!', 'success');
                
                hideEditGameIdeaForm();
                await loadGameIdeas();
                
            } catch (error) {
                console.error('❌ Error updating game idea:', error);
                showNotification('Error updating game idea: ' + error.message, 'error');
            }
        }

        // Delete a game idea
        async function deleteGameIdea(gameId) {
            if (confirm('Are you sure you want to delete this game idea?')) {
                try {
                    await db.collection('gameIdeas').doc(gameId).delete();
                    console.log(`✅ Game idea deleted: ${gameId}`);
                    showNotification('Game idea deleted successfully!', 'success');
                    await loadGameIdeas();
                } catch (error) {
                    console.error('❌ Error deleting game idea:', error);
                    showNotification('Error deleting game idea: ' + error.message, 'error');
                }
            }
        }

        // ================================
        // OBJECT-BASED RECOMMENDATIONS
        // ================================

        // Store selected objects
        let selectedObjects = [];
        let searchHistory = [];

        // Load search history from localStorage
        function loadSearchHistory() {
            const saved = localStorage.getItem('objectSearchHistory');
            if (saved) {
                searchHistory = JSON.parse(saved);
                displaySearchHistory();
            }
        }

        // Save search to history
        function saveSearchToHistory(objects, results) {
            const search = {
                objects: [...objects],
                resultCount: results.length,
                timestamp: new Date().toISOString(),
                id: Date.now()
            };
            
            searchHistory.unshift(search);
            searchHistory = searchHistory.slice(0, 10); // Keep only last 10 searches
            localStorage.setItem('objectSearchHistory', JSON.stringify(searchHistory));
            displaySearchHistory();
        }

        // Display search history
        function displaySearchHistory() {
            const container = document.getElementById('searchHistory');
            
            if (searchHistory.length === 0) {
                container.innerHTML = '<p class="no-history">No recent searches yet. Start by searching for objects above!</p>';
                return;
            }

            const html = searchHistory.map(search => `
                <div class="history-item">
                    <div class="history-objects">
                        ${search.objects.map(obj => `<span class="history-object">${obj}</span>`).join('')}
                    </div>
                    <div class="history-meta">
                        <span class="result-count">${search.resultCount} games found</span>
                        <span class="search-date">${new Date(search.timestamp).toLocaleDateString()}</span>
                        <button class="btn-repeat" onclick="repeatSearch(${search.id})" title="Search again">
                            <i class="fas fa-redo"></i>
                        </button>
                    </div>
                </div>
            `).join('');

            container.innerHTML = html;
        }

        // Repeat a previous search
        function repeatSearch(searchId) {
            const search = searchHistory.find(s => s.id === searchId);
            if (search) {
                selectedObjects = [...search.objects];
                updateObjectDisplay();
                findGamesByObjects();
            }
        }

        // Add quick object from category buttons
        function addQuickObject(objectName) {
            if (!selectedObjects.includes(objectName.toLowerCase())) {
                selectedObjects.push(objectName.toLowerCase());
                updateObjectDisplay();
            }
        }

        // Game database with objects - This would typically come from a real game database
        const gameDatabase = [
            {
                title: "The Witcher 3: Wild Hunt",
                description: "Open-world RPG with a rich fantasy setting",
                objects: ["sword", "horse", "prince", "princess", "castle", "crown", "armor", "magic", "potion", "book", "tavern", "ship"],
                genre: "RPG",
                platform: "PC, Console",
                rating: 9.3,
                image: "https://via.placeholder.com/200x120?text=Witcher+3"
            },
            {
                title: "Cyberpunk 2077",
                description: "Futuristic open-world action RPG",
                objects: ["laptop", "computer", "car", "gun", "cybernetics", "neon", "skyscraper", "robot", "hacker", "phone", "motorcycle"],
                genre: "Action RPG",
                platform: "PC, Console",
                rating: 7.8,
                image: "https://via.placeholder.com/200x120?text=Cyberpunk"
            },
            {
                title: "Minecraft",
                description: "Sandbox building and survival game",
                objects: ["block", "pickaxe", "sword", "bow", "diamond", "wood", "stone", "water", "lava", "animal", "monster", "house"],
                genre: "Sandbox",
                platform: "Multi-platform",
                rating: 9.0,
                image: "https://via.placeholder.com/200x120?text=Minecraft"
            },
            {
                title: "Papers, Please",
                description: "Immigration officer puzzle game",
                objects: ["passport", "stamp", "paper", "desk", "booth", "document", "photo", "border", "checkpoint", "rulebook"],
                genre: "Puzzle",
                platform: "PC, Mobile",
                rating: 8.5,
                image: "https://via.placeholder.com/200x120?text=Papers+Please"
            },
            {
                title: "Portal 2",
                description: "First-person puzzle-platform game",
                objects: ["portal gun", "cube", "button", "laser", "robot", "laboratory", "computer", "test chamber", "whiteboard", "scientist"],
                genre: "Puzzle",
                platform: "PC, Console",
                rating: 9.5,
                image: "https://via.placeholder.com/200x120?text=Portal+2"
            },
            {
                title: "Stardew Valley",
                description: "Farming simulation and life simulation game",
                objects: ["farm", "crops", "animals", "tools", "seeds", "barn", "chicken", "cow", "fish", "mine", "pickaxe", "watering can"],
                genre: "Simulation",
                platform: "Multi-platform",
                rating: 9.1,
                image: "https://via.placeholder.com/200x120?text=Stardew+Valley"
            },
            {
                title: "Grand Theft Auto V",
                description: "Open-world action-adventure game",
                objects: ["car", "gun", "money", "helicopter", "plane", "motorcycle", "bank", "police", "city", "beach", "skyscraper"],
                genre: "Action",
                platform: "PC, Console",
                rating: 8.7,
                image: "https://via.placeholder.com/200x120?text=GTA+V"
            },
            {
                title: "Among Us",
                description: "Social deduction multiplayer game",
                objects: ["spaceship", "crewmate", "impostor", "task", "vent", "emergency button", "security camera", "reactor", "oxygen"],
                genre: "Social Deduction",
                platform: "Mobile, PC",
                rating: 7.9,
                image: "https://via.placeholder.com/200x120?text=Among+Us"
            },
            {
                title: "The Legend of Zelda: Breath of the Wild",
                description: "Open-world action-adventure game",
                objects: ["sword", "shield", "bow", "horse", "princess", "castle", "temple", "shrine", "paraglider", "cooking pot", "apple"],
                genre: "Action Adventure",
                platform: "Nintendo Switch",
                rating: 9.7,
                image: "https://via.placeholder.com/200x120?text=Zelda+BOTW"
            },
            {
                title: "Cities: Skylines",
                description: "City-building simulation game",
                objects: ["building", "road", "bridge", "hospital", "school", "police station", "fire station", "park", "skyscraper", "traffic"],
                genre: "Simulation",
                platform: "PC, Console",
                rating: 8.6,
                image: "https://via.placeholder.com/200x120?text=Cities+Skylines"
            }
        ];

        // Handle object input
        function handleObjectInput(event) {
            if (event.key === 'Enter') {
                addObject();
            }
        }

        // Add object to selection
        function addObject() {
            const input = document.getElementById('objectInput');
            const objectText = input.value.trim().toLowerCase();
            
            if (objectText && !selectedObjects.includes(objectText)) {
                selectedObjects.push(objectText);
                input.value = '';
                updateObjectDisplay();
            }
        }

        // Update object display
        function updateObjectDisplay() {
            const container = document.getElementById('selectedObjects');
            container.innerHTML = selectedObjects.map(obj => `
                <span class="object-tag">
                    ${obj}
                    <button onclick="removeObject('${obj}')" class="remove-tag">×</button>
                </span>
            `).join('');
        }

        // Remove object from selection
        function removeObject(objectToRemove) {
            selectedObjects = selectedObjects.filter(obj => obj !== objectToRemove);
            updateObjectDisplay();
        }

        // Clear all objects
        function clearObjects() {
            selectedObjects = [];
            updateObjectDisplay();
            document.getElementById('objectRecommendations').style.display = 'none';
        }

        // Find games by objects
        function findGamesByObjects() {
            if (selectedObjects.length === 0) {
                showNotification('Please add some objects first!', 'warning');
                return;
            }

            // Also check user input for comma-separated values
            const input = document.getElementById('objectInput');
            if (input.value.trim()) {
                const inputObjects = input.value.split(',').map(obj => obj.trim().toLowerCase()).filter(obj => obj);
                inputObjects.forEach(obj => {
                    if (!selectedObjects.includes(obj)) {
                        selectedObjects.push(obj);
                    }
                });
                input.value = '';
                updateObjectDisplay();
            }

            // Calculate game matches
            const gameMatches = gameDatabase.map(game => {
                const matchingObjects = selectedObjects.filter(obj => 
                    game.objects.some(gameObj => 
                        gameObj.toLowerCase().includes(obj) || obj.includes(gameObj.toLowerCase())
                    )
                );
                
                const matchScore = matchingObjects.length / selectedObjects.length;
                return {
                    ...game,
                    matchingObjects,
                    matchScore,
                    matchPercentage: Math.round(matchScore * 100)
                };
            }).filter(game => game.matchScore > 0)
              .sort((a, b) => b.matchScore - a.matchScore);

            // Save to search history
            saveSearchToHistory(selectedObjects, gameMatches);

            displayGameRecommendations(gameMatches);
        }

        // Display game recommendations
        function displayGameRecommendations(games) {
            const container = document.getElementById('recommendedGames');
            const resultsSection = document.getElementById('objectRecommendations');
            
            if (games.length === 0) {
                container.innerHTML = '<p class="no-results">No games found with those objects. Try different or more common objects!</p>';
                resultsSection.style.display = 'block';
                return;
            }

            const html = games.map(game => `
                <div class="recommended-game-card">
                    <div class="game-image">
                        <img src="${game.image}" alt="${game.title}" onerror="this.src='https://via.placeholder.com/200x120?text=Game'">
                        <div class="match-badge">${game.matchPercentage}% Match</div>
                    </div>
                    <div class="game-info">
                        <h4>${game.title}</h4>
                        <p class="game-genre">${game.genre} • ${game.platform}</p>
                        <p class="game-description">${game.description}</p>
                        
                        <div class="matching-objects">
                            <strong>Found objects:</strong>
                            <div class="object-list">
                                ${game.matchingObjects.map(obj => `<span class="matched-object">${obj}</span>`).join('')}
                            </div>
                        </div>
                        
                        <div class="game-rating">
                            <i class="fas fa-star"></i> ${game.rating}/10
                        </div>
                        
                        <div class="game-actions">
                            <button class="btn btn-sm btn-primary" onclick="saveGameRecommendation('${game.title}')">
                                <i class="fas fa-bookmark"></i> Save
                            </button>
                            <button class="btn btn-sm btn-info" onclick="shareRecommendation('${game.title}')">
                                <i class="fas fa-share"></i> Share
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');

            container.innerHTML = html;
            resultsSection.style.display = 'block';

            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth' });
            
            showNotification(`Found ${games.length} games matching your objects!`, 'success');
        }

        // Save game recommendation
        async function saveGameRecommendation(gameTitle) {
            try {
                const recommendationData = {
                    gameTitle: gameTitle,
                    searchObjects: [...selectedObjects],
                    userId: getOrCreateUserId(),
                    createdAt: new Date().toISOString(),
                    type: 'object_based_recommendation',
                    notes: ''
                };

                const docRef = await db.collection('savedRecommendations').add(recommendationData);
                console.log(`✅ Recommendation saved with ID: ${docRef.id}`);
                showNotification(`Saved "${gameTitle}" to your recommendations!`, 'success');
                
                // Refresh stats and saved recommendations
                await refreshStats();
                await loadSavedRecommendations();
                
            } catch (error) {
                console.error('❌ Error saving recommendation:', error);
                showNotification('Error saving recommendation: ' + error.message, 'error');
            }
        }

        // Load saved recommendations
        async function loadSavedRecommendations() {
            try {
                const snapshot = await db.collection('savedRecommendations').orderBy('createdAt', 'desc').get();
                const recommendations = [];
                
                snapshot.forEach(doc => {
                    recommendations.push({ id: doc.id, ...doc.data() });
                });

                const html = recommendations.length > 0 
                    ? recommendations.map(rec => `
                        <div class="saved-recommendation-card">
                            <h4>${rec.gameTitle}</h4>
                            <p><strong>Search Objects:</strong> ${rec.searchObjects ? rec.searchObjects.join(', ') : 'None'}</p>
                            <p><strong>Saved:</strong> ${new Date(rec.createdAt).toLocaleDateString()}</p>
                            ${rec.notes ? `<p><strong>Notes:</strong> ${rec.notes}</p>` : ''}
                            <div class="card-actions">
                                <button onclick="editSavedRecommendation('${rec.id}')" class="btn btn-sm btn-primary">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                                <button onclick="deleteSavedRecommendation('${rec.id}')" class="btn btn-sm btn-danger">
                                    <i class="fas fa-trash"></i> Delete
                                </button>
                                <button onclick="reSearchObjects('${rec.searchObjects ? rec.searchObjects.join(',') : ''}')" class="btn btn-sm btn-info">
                                    <i class="fas fa-search"></i> Search Again
                                </button>
                            </div>
                        </div>
                    `).join('')
                    : '<p>No saved recommendations yet. Save some game recommendations to see them here!</p>';

                document.getElementById('savedRecommendationsList').innerHTML = html;
                console.log(`✅ Loaded ${recommendations.length} saved recommendations`);
                
            } catch (error) {
                console.error('❌ Error loading saved recommendations:', error);
                document.getElementById('savedRecommendationsList').innerHTML = `<p>Loading saved recommendations...</p>`;
            }
        }

        // Edit saved recommendation
        async function editSavedRecommendation(recId) {
            try {
                const recDoc = await db.collection('savedRecommendations').doc(recId).get();
                if (recDoc.exists) {
                    const recData = recDoc.data();
                    
                    // Populate form fields
                    document.getElementById('editRecommendationId').value = recId;
                    document.getElementById('editGameTitle').value = recData.gameTitle || '';
                    document.getElementById('editSearchObjects').value = recData.searchObjects ? recData.searchObjects.join(', ') : '';
                    document.getElementById('editNotes').value = recData.notes || '';
                    
                    // Show the edit form
                    document.getElementById('editRecommendationForm').style.display = 'block';
                    document.getElementById('editRecommendationForm').scrollIntoView({ behavior: 'smooth' });
                }
            } catch (error) {
                console.error('Error loading recommendation for editing:', error);
                showNotification('Error loading recommendation: ' + error.message, 'error');
            }
        }

        // Hide edit recommendation form
        function hideEditRecommendationForm() {
            document.getElementById('editRecommendationForm').style.display = 'none';
        }

        // Update recommendation
        async function updateRecommendation(event) {
            event.preventDefault();
            
            try {
                const recId = document.getElementById('editRecommendationId').value;
                const updateData = {
                    gameTitle: document.getElementById('editGameTitle').value,
                    notes: document.getElementById('editNotes').value,
                    updatedAt: new Date().toISOString()
                };

                await db.collection('savedRecommendations').doc(recId).update(updateData);
                console.log(`✅ Recommendation updated: ${recId}`);
                showNotification('Recommendation updated successfully!', 'success');
                
                hideEditRecommendationForm();
                await loadSavedRecommendations();
                
            } catch (error) {
                console.error('❌ Error updating recommendation:', error);
                showNotification('Error updating recommendation: ' + error.message, 'error');
            }
        }

        // Delete saved recommendation
        async function deleteSavedRecommendation(recId) {
            if (confirm('Are you sure you want to delete this saved recommendation?')) {
                try {
                    await db.collection('savedRecommendations').doc(recId).delete();
                    console.log(`✅ Recommendation deleted: ${recId}`);
                    showNotification('Recommendation deleted successfully!', 'success');
                    
                    await loadSavedRecommendations();
                    await refreshStats();
                    
                } catch (error) {
                    console.error('❌ Error deleting recommendation:', error);
                    showNotification('Error deleting recommendation: ' + error.message, 'error');
                }
            }
        }

        // Re-search with saved objects
        function reSearchObjects(objectsString) {
            if (objectsString) {
                const objects = objectsString.split(',').map(obj => obj.trim()).filter(obj => obj);
                selectedObjects = objects;
                updateSelectedObjectsDisplay();
                findGamesByObjects();
                
                // Scroll to top of object finder page
                document.querySelector('.object-input-container').scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Share recommendation
        function shareRecommendation(gameTitle) {
            const shareText = `Check out "${gameTitle}" - it has ${selectedObjects.join(', ')}! Found on Gamevibe Arena.`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'Game Recommendation',
                    text: shareText,
                    url: window.location.href
                });
            } else {
                // Fallback: copy to clipboard
                navigator.clipboard.writeText(shareText).then(() => {
                    showNotification('Recommendation copied to clipboard!', 'success');
                }).catch(() => {
                    showNotification('Could not copy to clipboard', 'error');
                });
            }
        }

        // ================================
        // LEADERBOARD FUNCTIONALITY
        // ================================

        // Load leaderboard data
        async function loadLeaderboard() {
            try {
                console.log('Loading leaderboard...');
                const sortBy = document.getElementById('sortBy').value;
                const filterTheme = document.getElementById('filterTheme').value;
                const filterType = document.getElementById('filterType').value;
                
                // Get all public game ideas first
                const snapshot = await db.collection('gameIdeas').where('isPublic', '==', true).get();
                let gameIdeas = [];
                
                snapshot.forEach(doc => {
                    gameIdeas.push({ id: doc.id, ...doc.data() });
                });
                
                // Apply client-side filtering
                if (filterTheme) {
                    gameIdeas = gameIdeas.filter(game => game.gameTheme === filterTheme);
                }
                if (filterType) {
                    gameIdeas = gameIdeas.filter(game => game.gameType === filterType);
                }
                
                // Apply client-side sorting
                switch (sortBy) {
                    case 'votes':
                        gameIdeas.sort((a, b) => (b.votes || 0) - (a.votes || 0));
                        break;
                    case 'recent':
                        gameIdeas.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                        break;
                }
                
                // Limit to top 20
                gameIdeas = gameIdeas.slice(0, 20);
                
                // Display leaderboard
                displayLeaderboard(gameIdeas);
                
                // Update stats
                await updateLeaderboardStats();
                
                console.log(`✅ Loaded ${gameIdeas.length} moodboards for leaderboard`);
                
            } catch (error) {
                console.error('❌ Error loading leaderboard:', error);
                document.getElementById('leaderboardContent').innerHTML = `<p>Loading leaderboard...</p>`;
            }
        }
        
        // Display leaderboard
        function displayLeaderboard(gameIdeas) {
            const leaderboardContent = document.getElementById('leaderboardContent');
            
            if (gameIdeas.length === 0) {
                leaderboardContent.innerHTML = '<p>No moodboards found for the selected filters.</p>';
                return;
            }
            
            const html = gameIdeas.map((game, index) => {
                const rank = index + 1;
                return `
                    <div class="leaderboard-item ${rank <= 3 ? 'top-three' : ''}" data-rank="${rank}">
                        <div class="rank-badge">
                            <span class="rank-number">#${rank}</span>
                            ${rank === 1 ? '<i class="fas fa-crown gold"></i>' : ''}
                            ${rank === 2 ? '<i class="fas fa-medal silver"></i>' : ''}
                            ${rank === 3 ? '<i class="fas fa-medal bronze"></i>' : ''}
                        </div>
                        
                        <div class="moodboard-preview">
                            ${game.images && game.images.length > 0 ? `
                                <div class="preview-images">
                                    ${game.images.slice(0, 2).map(img => `
                                        <img src="${img.url}" alt="${img.type || 'Game concept'}" class="preview-img">
                                    `).join('')}
                                </div>
                            ` : '<div class="no-preview">No Images</div>'}
                        </div>
                        
                        <div class="moodboard-info">
                            <h3 class="game-title">${game.gameType || 'Unknown'} - ${game.gameTheme || 'Unknown Theme'}</h3>
                            <p class="game-details">
                                <span class="detail-item"><i class="fas fa-palette"></i> ${game.artStyle || 'Unknown Style'}</span>
                                <span class="detail-item"><i class="fas fa-desktop"></i> ${game.targetPlatform || 'Unknown Platform'}</span>
                            </p>
                            <div class="game-description">
                                ${game.description ? game.description.substring(0, 150) + '...' : 'No description available'}
                            </div>
                            <div class="creation-date">
                                <i class="fas fa-calendar"></i> ${new Date(game.createdAt).toLocaleDateString()}
                            </div>
                        </div>
                        
                        <div class="voting-section">
            <div class="vote-stats">
                <div class="stat-item">
                    <span class="stat-number">${game.votes || 0}</span>
                    <span class="stat-label">Votes</span>
                </div>
            </div>
                            
                            <div class="voting-actions">
                                <button class="btn btn-vote vote-btn" onclick="voteForMoodboard('${game.id}')">
                                    <i class="fas fa-thumbs-up"></i> Vote
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            leaderboardContent.innerHTML = html;
        }
        
        // Vote for a moodboard
        async function voteForMoodboard(gameId) {
            try {
                // Get current user ID (for demo, we'll use a session-based ID)
                const userId = getOrCreateUserId();
                
                const gameRef = db.collection('gameIdeas').doc(gameId);
                const gameDoc = await gameRef.get();
                
                if (!gameDoc.exists) {
                    showNotification('Moodboard not found!', 'error');
                    return;
                }
                
                const gameData = gameDoc.data();
                const voters = gameData.voters || [];
                
                // Check if user already voted
                if (voters.includes(userId)) {
                    showNotification('You have already voted for this moodboard!', 'warning');
                    return;
                }
                
                // Update vote count and add user to voters
                await gameRef.update({
                    votes: (gameData.votes || 0) + 1,
                    voters: [...voters, userId]
                });
                
                showNotification('Vote cast successfully!', 'success');
                await loadLeaderboard(); // Refresh leaderboard
                
            } catch (error) {
                console.error('❌ Error voting:', error);
                showNotification('Error casting vote: ' + error.message, 'error');
            }
        }
        
        
        // View moodboard details
        async function viewMoodboardDetails(gameId) {
            try {
                const gameDoc = await db.collection('gameIdeas').doc(gameId).get();
                if (gameDoc.exists) {
                    const gameData = gameDoc.data();
                    
                    // Store and display the game idea in the Game Ideas section
                    window.currentGeneratedGame = gameData;
                    
                    // Switch to Game Ideas page
                    showPage('game-ideas');
                    
                    // Update form values
                    document.getElementById('gameType').value = gameData.gameType;
                    document.getElementById('gameTheme').value = gameData.gameTheme;
                    document.getElementById('artStyle').value = gameData.artStyle;
                    document.getElementById('targetPlatform').value = gameData.targetPlatform;
                    document.getElementById('additionalPrompts').value = gameData.additionalPrompts || '';
                    
                    // Display the moodboard
                    if (gameData.description && gameData.images) {
                        displayMoodboard(gameData.description, gameData.images);
                    }
                    
                    showNotification('Viewing moodboard details in Game Ideas section', 'info');
                }
            } catch (error) {
                console.error('❌ Error viewing moodboard:', error);
                showNotification('Loading moodboard...', 'info');
            }
        }
        
        // Update leaderboard stats
        async function updateLeaderboardStats() {
            try {
                const snapshot = await db.collection('gameIdeas').where('isPublic', '==', true).get();
                let totalVotes = 0;
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    totalVotes += data.votes || 0;
                });
                
                document.getElementById('totalMoodboards').textContent = snapshot.size;
                document.getElementById('totalVotes').textContent = totalVotes;
                
                // Also update dashboard stats to sync the moodboards count
                await refreshStats();
                
            } catch (error) {
                console.error('❌ Error updating leaderboard stats:', error);
            }
        }
        
        // Get or create user ID for voting (session-based)
        function getOrCreateUserId() {
            let userId = localStorage.getItem('gamehub_user_id');
            if (!userId) {
                userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2);
                localStorage.setItem('gamehub_user_id', userId);
            }
            return userId;
        }

        // Launch gesture generator function
        function launchGestureGenerator() {
            try {
                // For web-based launching, we'll show instructions
                alert('Please run the gesture generator by:\n\n1. Double-clicking run_gesture_generator.bat\n2. Or run: python gesture_game_generator.py\n\nMake sure your webcam is connected and working!');
                
                // Optional: Try to open file explorer to the directory
                // This won't work in all browsers due to security restrictions
                if (confirm('Would you like instructions on how to run the gesture generator?')) {
                    const instructions = `
                    GESTURE GENERATOR INSTRUCTIONS:
                    
                    1. Navigate to your fyp folder
                    2. Double-click 'run_gesture_generator.bat' 
                    3. OR open command prompt and run: python gesture_game_generator.py
                    4. Allow camera access when prompted
                    5. Perform hand gestures in front of your webcam
                    6. Watch AI generate game ideas based on your movements!
                    
                    Supported Gestures:
                    • Fist, Open Palm, Thumbs Up, Peace Sign
                    • Pointing, Pinch, Wave, Circle Motion
                    • Swipe Left/Right, Grab, Spread Fingers
                    `;
                    alert(instructions);
                }
            } catch (error) {
                console.error('Error launching gesture generator:', error);
                alert('Please manually run the gesture generator from your file explorer');
            }
        }

        // Launch eye tracker function
        function launchEyeTracker() {
            try {
                const instructions = `
                EYE TRACKING SYSTEM INSTRUCTIONS:
                
                1. Navigate to your fyp folder
                2. Double-click 'run_eye_tracker.bat'
                3. OR run: python multi_person_eye_tracker.py
                4. Allow camera access when prompted
                5. Position people in front of the webcam
                6. Click "Add Player Name" to name each person
                7. Monitor real-time health metrics and blink rates
                8. Save session data to Firebase when complete
                
                Features:
                • Multi-person face detection (up to 5 people)
                • Real-time blink rate monitoring
                • Health status assessment (12-20 BPM = healthy)
                • Individual player tracking with names
                • Firebase data storage and analytics
                • Comprehensive statistics dashboard
                `;
                
                alert('MULTI-PERSON EYE TRACKING SYSTEM\n\nThis advanced biometric monitoring system tracks multiple people\'s eye health simultaneously.');
                
                if (confirm('Would you like detailed launch instructions?')) {
                    alert(instructions);
                }
            } catch (error) {
                console.error('Error launching eye tracker:', error);
                alert('Please manually run the eye tracker from your file explorer');
            }
        }

    </script>

    <script src="js/app.js"></script>

</body>
</html>